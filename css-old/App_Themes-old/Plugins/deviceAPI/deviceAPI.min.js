"use strict"; !function t(e, n, i) { function r(a, o) { if (!n[a]) { if (!e[a]) { var u = "function" == typeof require && require; if (!o && u) return u(a, !0); if (s) return s(a, !0); var h = new Error("Cannot find module '" + a + "'"); throw h.code = "MODULE_NOT_FOUND", h } var l = n[a] = { exports: {} }; e[a][0].call(l.exports, function (t) { var n = e[a][1][t]; return r(n || t) }, l, l.exports, t, e, n, i) } return n[a].exports } for (var s = "function" == typeof require && require, a = 0; a < i.length; a++)r(i[a]); return r }({ 1: [function (t, e, n) { var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); var r = t("../function-builder-base"), s = t("./function-node"); e.exports = function (t) { function e() { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, e); var t = function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this)); return t.Node = s, t } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, r), i(e, [{ key: "polyfillStandardFunctions", value: function () { } }]), e }() }, { "../function-builder-base": 6, "./function-node": 2 }], 2: [function (t, e, n) { var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); var r = t("../function-node-base"), s = t("../../core/utils"); e.exports = function (t) { function e() { return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, e), function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)) } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, r), i(e, [{ key: "generate", value: function () { return this.debug && console.log(this), this.functionStringArray = this.astGeneric(this.getJsAST(), [], this), this.functionString = this.functionStringArray.join("").trim(), this.functionString } }, { key: "getFunctionPrototypeString", value: function () { return this.webGlFunctionPrototypeString ? this.webGlFunctionPrototypeString : this.webGlFunctionPrototypeString = this.generate() } }, { key: "astGeneric", value: function (t, e, n) { if (null === t) throw this.astErrorOutput("NULL ast", t, n); if (Array.isArray(t)) { for (var i = 0; i < t.length; i++)this.astGeneric(t[i], e, n); return e } switch (t.type) { case "FunctionDeclaration": return this.astFunctionDeclaration(t, e, n); case "FunctionExpression": return this.astFunctionExpression(t, e, n); case "ReturnStatement": return this.astReturnStatement(t, e, n); case "Literal": return this.astLiteral(t, e, n); case "BinaryExpression": return this.astBinaryExpression(t, e, n); case "Identifier": return this.astIdentifierExpression(t, e, n); case "AssignmentExpression": return this.astAssignmentExpression(t, e, n); case "ExpressionStatement": return this.astExpressionStatement(t, e, n); case "EmptyStatement": return this.astEmptyStatement(t, e, n); case "BlockStatement": return this.astBlockStatement(t, e, n); case "IfStatement": return this.astIfStatement(t, e, n); case "BreakStatement": return this.astBreakStatement(t, e, n); case "ContinueStatement": return this.astContinueStatement(t, e, n); case "ForStatement": return this.astForStatement(t, e, n); case "WhileStatement": return this.astWhileStatement(t, e, n); case "VariableDeclaration": return this.astVariableDeclaration(t, e, n); case "VariableDeclarator": return this.astVariableDeclarator(t, e, n); case "ThisExpression": return this.astThisExpression(t, e, n); case "SequenceExpression": return this.astSequenceExpression(t, e, n); case "UnaryExpression": return this.astUnaryExpression(t, e, n); case "UpdateExpression": return this.astUpdateExpression(t, e, n); case "LogicalExpression": return this.astLogicalExpression(t, e, n); case "MemberExpression": return this.astMemberExpression(t, e, n); case "CallExpression": return this.astCallExpression(t, e, n); case "ArrayExpression": return this.astArrayExpression(t, e, n); case "DebuggerStatement": return this.astDebuggerStatement(t, e, n) }throw this.astErrorOutput("Unknown ast type : " + t.type, t, n) } }, { key: "astFunctionDeclaration", value: function (t, e, n) { return this.addFunction && this.addFunction(null, s.getAstString(this.jsFunctionString, t)), e } }, { key: "astFunctionExpression", value: function (t, e, n) { if (!n.isRootKernel) { e.push("function"), n.kernalAst = t, e.push(" "), e.push(n.functionName), e.push("("); for (var i = 0; i < n.paramNames.length; ++i) { var r = n.paramNames[i]; i > 0 && e.push(", "), e.push(" "), e.push("user_"), e.push(r) } e.push(") {\n") } for (var s = 0; s < t.body.body.length; ++s)this.astGeneric(t.body.body[s], e, n), e.push("\n"); return n.isRootKernel || e.push("}\n"), e } }, { key: "astReturnStatement", value: function (t, e, n) { return n.isRootKernel ? (e.push("kernelResult = "), this.astGeneric(t.argument, e, n), e.push(";")) : n.isSubKernel ? (e.push(n.functionName + "Result = "), this.astGeneric(t.argument, e, n), e.push(";"), e.push("return " + n.functionName + "Result;")) : (e.push("return "), this.astGeneric(t.argument, e, n), e.push(";")), e } }, { key: "astLiteral", value: function (t, e, n) { if (isNaN(t.value)) throw this.astErrorOutput("Non-numeric literal not supported : " + t.value, t, n); return e.push(t.value), e } }, { key: "astBinaryExpression", value: function (t, e, n) { return e.push("("), this.astGeneric(t.left, e, n), e.push(t.operator), this.astGeneric(t.right, e, n), e.push(")"), e } }, { key: "astIdentifierExpression", value: function (t, e, n) { if ("Identifier" !== t.type) throw this.astErrorOutput("IdentifierExpression - not an Identifier", t, n); switch (t.name) { case "gpu_threadX": e.push("threadId.x"); break; case "gpu_threadY": e.push("threadId.y"); break; case "gpu_threadZ": e.push("threadId.z"); break; case "gpu_outputX": e.push("uOutputDim.x"); break; case "gpu_outputY": e.push("uOutputDim.y"); break; case "gpu_outputZ": e.push("uOutputDim.z"); break; default: if (this.constants && this.constants.hasOwnProperty(t.name)) e.push("constants_" + t.name); else { var i = n.getUserParamName(t.name); null !== i ? e.push("user_" + i) : e.push("user_" + t.name) } }return e } }, { key: "astForStatement", value: function (t, e, n) { if ("ForStatement" !== t.type) throw this.astErrorOutput("Invalid for statment", t, n); if (t.test && "BinaryExpression" === t.test.type) { if (("Identifier" === t.test.right.type || "Literal" === t.test.right.type) && "<" === t.test.operator && !1 === this.isIdentifierConstant(t.test.right.name)) { if (this.loopMaxIterations || (console.warn("Warning: loopMaxIterations is not set! Using default of 1000 which may result in unintended behavior."), console.warn("Set loopMaxIterations or use a for loop of fixed length to silence this message.")), e.push("for ("), this.astGeneric(t.init, e, n), ";" !== e[e.length - 1] && e.push(";"), this.astGeneric(t.test.left, e, n), e.push(t.test.operator), e.push("LOOP_MAX"), e.push(";"), this.astGeneric(t.update, e, n), e.push(")"), e.push("{\n"), e.push("if ("), this.astGeneric(t.test.left, e, n), e.push(t.test.operator), this.astGeneric(t.test.right, e, n), e.push(") {\n"), "BlockStatement" === t.body.type) for (var i = 0; i < t.body.body.length; i++)this.astGeneric(t.body.body[i], e, n); else this.astGeneric(t.body, e, n); return e.push("} else {\n"), e.push("break;\n"), e.push("}\n"), e.push("}\n"), e } if (t.init.declarations) { var r = JSON.parse(JSON.stringify(t.init.declarations)), s = t.update.argument; if (!Array.isArray(r) || r.length < 1) throw console.log(this.jsFunctionString), new Error("Error: Incompatible for loop declaration"); if (r.length > 1) { for (var a = null, o = 0; o < r.length; o++) { var u = r[o]; u.id.name === s.name ? (a = u, r.splice(o, 1)) : (e.push("var "), this.astGeneric(u, e, n), e.push(";")) } e.push("for (let "), this.astGeneric(a, e, n), e.push(";") } else e.push("for ("), this.astGeneric(t.init, e, n); return this.astGeneric(t.test, e, n), e.push(";"), this.astGeneric(t.update, e, n), e.push(")"), this.astGeneric(t.body, e, n), e } } throw this.astErrorOutput("Invalid for statement", t, n) } }, { key: "astWhileStatement", value: function (t, e, n) { if ("WhileStatement" !== t.type) throw this.astErrorOutput("Invalid while statment", t, n); return e.push("for (let i = 0; i < LOOP_MAX; i++) {"), e.push("if ("), this.astGeneric(t.test, e, n), e.push(") {\n"), this.astGeneric(t.body, e, n), e.push("} else {\n"), e.push("break;\n"), e.push("}\n"), e.push("}\n"), e } }, { key: "astAssignmentExpression", value: function (t, e, n) { return this.astGeneric(t.left, e, n), e.push(t.operator), this.astGeneric(t.right, e, n), e } }, { key: "astEmptyStatement", value: function (t, e, n) { return e } }, { key: "astBlockStatement", value: function (t, e, n) { e.push("{\n"); for (var i = 0; i < t.body.length; i++)this.astGeneric(t.body[i], e, n); return e.push("}\n"), e } }, { key: "astExpressionStatement", value: function (t, e, n) { return this.astGeneric(t.expression, e, n), e.push(";\n"), e } }, { key: "astVariableDeclaration", value: function (t, e, n) { e.push("var "); for (var i = 0; i < t.declarations.length; i++)i > 0 && e.push(","), this.astGeneric(t.declarations[i], e, n); return e.push(";"), e } }, { key: "astVariableDeclarator", value: function (t, e, n) { return this.astGeneric(t.id, e, n), null !== t.init && (e.push("="), this.astGeneric(t.init, e, n)), e } }, { key: "astIfStatement", value: function (t, e, n) { return e.push("if ("), this.astGeneric(t.test, e, n), e.push(")"), "BlockStatement" === t.consequent.type ? this.astGeneric(t.consequent, e, n) : (e.push(" {\n"), this.astGeneric(t.consequent, e, n), e.push("\n}\n")), t.alternate && (e.push("else "), "BlockStatement" === t.alternate.type ? this.astGeneric(t.alternate, e, n) : (e.push(" {\n"), this.astGeneric(t.alternate, e, n), e.push("\n}\n"))), e } }, { key: "astBreakStatement", value: function (t, e, n) { return e.push("break;\n"), e } }, { key: "astContinueStatement", value: function (t, e, n) { return e.push("continue;\n"), e } }, { key: "astLogicalExpression", value: function (t, e, n) { return e.push("("), this.astGeneric(t.left, e, n), e.push(t.operator), this.astGeneric(t.right, e, n), e.push(")"), e } }, { key: "astUpdateExpression", value: function (t, e, n) { return t.prefix ? (e.push(t.operator), this.astGeneric(t.argument, e, n)) : (this.astGeneric(t.argument, e, n), e.push(t.operator)), e } }, { key: "astUnaryExpression", value: function (t, e, n) { return t.prefix ? (e.push(t.operator), this.astGeneric(t.argument, e, n)) : (this.astGeneric(t.argument, e, n), e.push(t.operator)), e } }, { key: "astThisExpression", value: function (t, e, n) { return e.push("_this"), e } }, { key: "astMemberExpression", value: function (t, e, n) { if (t.computed) if ("Identifier" === t.object.type) this.astGeneric(t.object, e, n), e.push("["), this.astGeneric(t.property, e, n), e.push("]"); else { this.astGeneric(t.object, e, n); var i = e.pop(); e.push("]["), this.astGeneric(t.property, e, n), e.push(i) } else { var r = this.astMemberExpressionUnroll(t); switch ("Identifier" === t.property.type && t.computed && (r = "user_" + r), 0 === r.indexOf("this") && (r = "_" + r), r) { case "_this.output.x": e.push(this.output[0]); break; case "_this.output.y": e.push(this.output[1]); break; case "_this.output.z": e.push(this.output[2]); break; default: e.push(r) } } return e } }, { key: "astSequenceExpression", value: function (t, e, n) { for (var i = 0; i < t.expressions.length; i++)i > 0 && e.push(","), this.astGeneric(t.expressions, e, n); return e } }, { key: "astCallExpression", value: function (t, e, n) { if (t.callee) { var i = this.astMemberExpressionUnroll(t.callee); n.calledFunctions.indexOf(i) < 0 && n.calledFunctions.push(i), n.hasOwnProperty("funcName") || (n.calledFunctionsArguments[i] = []); var r = []; n.calledFunctionsArguments[i].push(r), e.push(i), e.push("("); for (var s = 0; s < t.arguments.length; ++s) { var a = t.arguments[s]; if (s > 0 && e.push(", "), this.astGeneric(a, e, n), "Identifier" === a.type) { var o = n.paramNames.indexOf(a.name); -1 === o ? r.push(null) : r.push({ name: a.name, type: n.paramTypes[o] }) } else r.push(null) } return e.push(")"), e } throw this.astErrorOutput("Unknown CallExpression", t, n) } }, { key: "astArrayExpression", value: function (t, e, n) { var i = t.elements.length; e.push("new Float32Array("); for (var r = 0; r < i; ++r) { r > 0 && e.push(", "); var s = t.elements[r]; this.astGeneric(s, e, n) } return e.push(")"), e } }, { key: "astDebuggerStatement", value: function (t, e, n) { return e.push("debugger;"), e } }], [{ key: "astFunctionPrototype", value: function (t, e, n) { if (n.isRootKernel || n.isSubKernel) return e; e.push(n.returnType), e.push(" "), e.push(n.functionName), e.push("("); for (var i = 0; i < n.paramNames.length; ++i)i > 0 && e.push(", "), e.push(n.paramTypes[i]), e.push(" "), e.push("user_"), e.push(n.paramNames[i]); return e.push(");\n"), e } }]), e }() }, { "../../core/utils": 25, "../function-node-base": 7 }], 3: [function (t, e, n) { var i = t("../../core/utils"), r = t("../kernel-run-shortcut"); e.exports = function (t, e) { return "() => {\n    " + r.toString() + ";\n    const utils = {\n      allPropertiesOf: function " + i.allPropertiesOf.toString() + ",\n      clone: function " + i.clone.toString() + ",\n      /*splitArray: function " + i.splitArray.toString() + ",\n      getArgumentType: function " + i.getArgumentType.toString() + ",\n      getOutput: function " + i.getOutput.toString() + ",\n      dimToTexSize: function " + i.dimToTexSize.toString() + ",\n      copyFlatten: function " + i.copyFlatten.toString() + ",\n      flatten: function " + i.flatten.toString() + ",\n      systemEndianness: '" + i.systemEndianness() + "',\n      initWebGl: function " + i.initWebGl.toString() + ",\n      isArray: function " + i.isArray.toString() + "*/\n    };\n    class " + (e || "Kernel") + " {\n      constructor() {        \n        this.argumentsLength = 0;\n        this._canvas = null;\n        this._webGl = null;\n        this.built = false;\n        this.program = null;\n        this.paramNames = " + JSON.stringify(t.paramNames) + ";\n        this.paramTypes = " + JSON.stringify(t.paramTypes) + ";\n        this.texSize = " + JSON.stringify(t.texSize) + ";\n        this.output = " + JSON.stringify(t.output) + ";\n        this._kernelString = `" + t._kernelString + "`;\n        this.output = " + JSON.stringify(t.output) + ";\n\t\t    this.run = function() {\n          this.run = null;\n          this.build();\n          return this.run.apply(this, arguments);\n        }.bind(this);\n        this.thread = {\n          x: 0,\n          y: 0,\n          z: 0\n        };\n      }\n      setCanvas(canvas) { this._canvas = canvas; return this; }\n      setWebGl(webGl) { this._webGl = webGl; return this; }\n      " + t.build.toString() + "\n      run () { " + t.kernelString + " }\n      getKernelString() { return this._kernelString; }\n    };\n    return kernelRunShortcut(new Kernel());\n  };" } }, { "../../core/utils": 25, "../kernel-run-shortcut": 9 }], 4: [function (t, e, n) { var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); var r = t("../kernel-base"), s = t("../../core/utils"), a = t("./kernel-string"); e.exports = function (t) { function e(t, n) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, e); var i = function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)); return i._fnBody = s.getFunctionBodyFromString(t), i._fn = null, i.run = null, i._canvasCtx = null, i._imageData = null, i._colorData = null, i._kernelString = null, i.thread = { x: 0, y: 0, z: 0 }, i.run = function () { return this.run = null, this.build.apply(this, arguments), this.run.apply(this, arguments) }.bind(i), i } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, r), i(e, [{ key: "validateOptions", value: function () { if (!this.output || 0 === this.output.length) { if (1 !== arguments.length) throw "Auto dimensions only supported for kernels with only one input"; var t = s.getArgumentType(arguments[0]); if ("Array" === t) this.output = s.getDimensions(t); else { if ("Texture" !== t) throw "Auto dimensions not supported for input type: " + t; this.output = arguments[0].output } } } }, { key: "build", value: function () { this.setupParams(arguments); for (var t = this.threadDim = s.clone(this.output); t.length < 3;)t.push(1); if (this.graphical) { var e = this.getCanvas(); e.width = t[0], e.height = t[1], this._canvasCtx = e.getContext("2d"), this._imageData = this._canvasCtx.createImageData(t[0], t[1]), this._colorData = new Uint8ClampedArray(t[0] * t[1] * 4) } var n = this.getKernelString(); this.debug && (console.log("Options:"), console.dir(this), console.log("Function output:"), console.log(n)), this.kernelString = n, this.run = new Function([], n).bind(this)() } }, { key: "color", value: function (t, e, n, i) { void 0 === i && (i = 1), t = Math.floor(255 * t), e = Math.floor(255 * e), n = Math.floor(255 * n), i = Math.floor(255 * i); var r = this.output[0], s = this.output[1], a = this.thread.x + (s - this.thread.y - 1) * r; this._colorData[4 * a + 0] = t, this._colorData[4 * a + 1] = e, this._colorData[4 * a + 2] = n, this._colorData[4 * a + 3] = i } }, { key: "getKernelString", value: function () { var t = this; if (null !== this._kernelString) return this._kernelString; for (var e = this.functionBuilder, n = this.threadDim || (this.threadDim = s.clone(this.output)); n.length < 3;)n.push(1); if (e.addKernel(this.fnString, { prototypeOnly: !1, constants: this.constants, output: this.output, debug: this.debug, loopMaxIterations: this.loopMaxIterations }, this.paramNames, this.paramTypes), e.addFunctions(this.functions, { constants: this.constants, output: this.output }), null !== this.subKernels) { this.subKernelOutputTextures = [], this.subKernelOutputVariableNames = []; for (var i = 0; i < this.subKernels.length; i++) { var r = this.subKernels[i]; e.addSubKernel(r, { prototypeOnly: !1, constants: this.constants, output: this.output, debug: this.debug, loopMaxIterations: this.loopMaxIterations }), this.subKernelOutputVariableNames.push(r.name + "Result") } } else if (null !== this.subKernelProperties) { this.subKernelOutputVariableNames = []; for (var a in this.subKernelProperties) if (this.subKernelProperties.hasOwnProperty(a)) { var o = this.subKernelProperties[a]; e.addSubKernel(o), this.subKernelOutputVariableNames.push(o.name + "Result"), 0 } } var u = e.getPrototypes(), h = u.shift(); return this._kernelString = "\n\t\tvar LOOP_MAX = " + this._getLoopMaxString() + ";\n\t\tvar _this = this;\n  " + (null === this.subKernelOutputVariableNames ? "" : this.subKernelOutputVariableNames.map(function (t) { return "  var " + t + " = null;\n" }).join("")) + "\n    return function (" + this.paramNames.map(function (t) { return "user_" + t }).join(", ") + ") {\n    var ret = new Array(" + n[2] + ");\n  " + (null === this.subKernelOutputVariableNames ? "" : this.subKernelOutputVariableNames.map(function (t) { return "  " + t + "Z = new Array(" + n[2] + ");\n" }).join("")) + "\n    for (this.thread.z = 0; this.thread.z < " + n[2] + "; this.thread.z++) {\n      ret[this.thread.z] = new Array(" + n[1] + ");\n  " + (null === this.subKernelOutputVariableNames ? "" : this.subKernelOutputVariableNames.map(function (t) { return "    " + t + "Z[this.thread.z] = new Array(" + n[1] + ");\n" }).join("")) + "\n      for (this.thread.y = 0; this.thread.y < " + n[1] + "; this.thread.y++) {\n        ret[this.thread.z][this.thread.y] = new Array(" + n[0] + ");\n  " + (null === this.subKernelOutputVariableNames ? "" : this.subKernelOutputVariableNames.map(function (t) { return "      " + t + "Z[this.thread.z][this.thread.y] = new Array(" + n[0] + ");\n" }).join("")) + "\n        for (this.thread.x = 0; this.thread.x < " + n[0] + "; this.thread.x++) {\n          var kernelResult;\n          " + h + "\n          ret[this.thread.z][this.thread.y][this.thread.x] = kernelResult;\n" + (null === this.subKernelOutputVariableNames ? "" : this.subKernelOutputVariableNames.map(function (t) { return "        " + t + "Z[this.thread.z][this.thread.y][this.thread.x] = " + t + ";\n" }).join("")) + "\n          }\n        }\n      }\n      \n      if (this.graphical) {\n        this._imageData.data.set(this._colorData);\n        this._canvasCtx.putImageData(this._imageData, 0, 0);\n        return;\n      }\n      \n      if (this.output.length === 1) {\n        ret = ret[0][0];\n" + (null === this.subKernelOutputVariableNames ? "" : this.subKernelOutputVariableNames.map(function (t) { return "    " + t + " = " + t + "Z[0][0];\n" }).join("")) + "\n      \n    } else if (this.output.length === 2) {\n      ret = ret[0];\n      " + (null === this.subKernelOutputVariableNames ? "" : this.subKernelOutputVariableNames.map(function (t) { return "    " + t + " = " + t + "Z[0];\n" }).join("")) + "\n    }\n    \n    " + (null === this.subKernelOutputVariableNames ? "return ret;\n" : null !== this.subKernels ? "var result = [\n        " + this.subKernelOutputVariableNames.map(function (t) { return "" + t }).join(",\n") + "\n      ];\n      result.result = ret;\n      return result;\n" : "return {\n        result: ret,\n        " + Object.keys(this.subKernelProperties).map(function (e, n) { return e + ": " + t.subKernelOutputVariableNames[n] }).join(",\n") + "\n      };") + "\n    " + (u.length > 0 ? u.join("\n") : "") + "\n    }.bind(this);" } }, { key: "toString", value: function () { return a(this) } }, { key: "precompileKernelObj", value: function (t) { return { threadDim: this.threadDim || (this.threadDim = s.clone(this.output)) } } }, { key: "_getLoopMaxString", value: function () { return this.loopMaxIterations ? " " + parseInt(this.loopMaxIterations) + ";\n" : " 1000;\n" } }], [{ key: "compileKernel", value: function (t) { for (var e = t.threadDim; e.length < 3;)e.push(1) } }]), e }() }, { "../../core/utils": 25, "../kernel-base": 8, "./kernel-string": 3 }], 5: [function (t, e, n) { var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); t("../../core/utils"); var r = t("../runner-base"), s = t("./kernel"), a = t("./function-builder"); e.exports = function (t) { function e(t) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, e); var n = function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, new a, t)); return n.Kernel = s, n.kernel = null, n } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, r), i(e, [{ key: "getMode", value: function () { return "cpu" } }]), e }() }, { "../../core/utils": 25, "../runner-base": 10, "./function-builder": 1, "./kernel": 4 }], 6: [function (t, e, n) { var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); e.exports = function () { function t(e) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.nodeMap = {}, this.nativeFunctions = {}, this.gpu = e, this.rootKernel = null, this.Node = null } return i(t, [{ key: "addNativeFunction", value: function (t, e) { this.nativeFunctions[t] = e } }, { key: "addFunction", value: function (t, e, n, i, r) { this.addFunctionNode(new this.Node(t, e, n, i, r).setAddFunction(this.addFunction.bind(this))) } }, { key: "addFunctions", value: function (t, e) { if (t) if (Array.isArray(t)) for (var n = 0; n < t.length; n++)this.addFunction(null, t[n], e); else for (var i in t) this.addFunction(i, t[i], e) } }, { key: "addNativeFunctions", value: function (t) { for (var e in t) t.hasOwnProperty(e) && this.addNativeFunction(e, t[e]) } }, { key: "addFunctionNode", value: function (t) { this.nodeMap[t.functionName] = t, t.isRootKernel && (this.rootKernel = t) } }, { key: "traceFunctionCalls", value: function (t, e, n) { t = t || "kernel", e = e || []; var i = this.nodeMap[t]; if (i) { var r = e.indexOf(t); if (-1 === r) { e.push(t), n && (i.parent = n), i.getFunctionString(); for (var s = 0; s < i.calledFunctions.length; ++s)this.traceFunctionCalls(i.calledFunctions[s], e, i) } else { var a = e.splice(r, 1)[0]; e.push(a) } } return this.nativeFunctions[t] && (e.indexOf(t) >= 0 || e.push(t)), e } }, { key: "addKernel", value: function (t, e, n, i) { var r = new this.Node("kernel", t, e, i); return r.setAddFunction(this.addFunction.bind(this)), r.paramNames = n, r.paramTypes = i, r.isRootKernel = !0, this.addFunctionNode(r), r } }, { key: "addSubKernel", value: function (t, e, n, i) { var r = new this.Node(null, t, e, n, i); return r.setAddFunction(this.addFunction.bind(this)), r.isSubKernel = !0, this.addFunctionNode(r), r } }, { key: "getPrototypeString", value: function (t) { return this.getPrototypes(t).join("\n") } }, { key: "getPrototypes", value: function (t) { return this.rootKernel.generate(), t ? this.getPrototypesFromFunctionNames(this.traceFunctionCalls(t, []).reverse()) : this.getPrototypesFromFunctionNames(Object.keys(this.nodeMap)) } }, { key: "getStringFromFunctionNames", value: function (t) { for (var e = [], n = 0; n < t.length; ++n) { this.nodeMap[t[n]] && e.push(this.nodeMap[t[n]].getFunctionString()) } return e.join("\n") } }, { key: "getPrototypesFromFunctionNames", value: function (t, e) { for (var n = [], i = 0; i < t.length; ++i) { var r = t[i], s = this.nodeMap[r]; s ? n.push(s.getFunctionPrototypeString(e)) : this.nativeFunctions[r] && n.push(this.nativeFunctions[r]) } return n } }, { key: "getPrototypeStringFromFunctionNames", value: function (t, e) { return this.getPrototypesFromFunctionNames(t, e).toString() } }, { key: "getString", value: function (t, e) { return void 0 === e && (e = {}), t ? this.getStringFromFunctionNames(this.traceFunctionCalls(t, [], e).reverse(), e) : this.getStringFromFunctionNames(Object.keys(this.nodeMap), e) } }, { key: "polyfillStandardFunctions", value: function () { throw new Error("polyfillStandardFunctions not defined on base function builder") } }]), t }() }, {}], 7: [function (require, module, exports) { var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, _createClass = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); function _classCallCheck(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } var utils = require("../core/utils"), acorn = require("acorn"); module.exports = function () { function BaseFunctionNode(t, e, n, i, r) { if (_classCallCheck(this, BaseFunctionNode), this.calledFunctions = [], this.calledFunctionsArguments = {}, this.initVariables = [], this.readVariables = [], this.writeVariables = [], this.addFunction = null, this.isRootKernel = !1, this.isSubKernel = !1, this.parent = null, this.debug = null, this.prototypeOnly = null, this.constants = null, this.output = null, n && (n.hasOwnProperty("debug") && (this.debug = n.debug), n.hasOwnProperty("prototypeOnly") && (this.prototypeOnly = n.prototypeOnly), n.hasOwnProperty("constants") && (this.constants = n.constants), n.hasOwnProperty("output") && (this.output = n.output), n.hasOwnProperty("loopMaxIterations") && (this.loopMaxIterations = n.loopMaxIterations)), !e) throw "jsFunction, parameter is missing"; if (this.jsFunctionString = e.toString(), !utils.isFunctionString(this.jsFunctionString)) throw console.error("jsFunction, to string conversion check failed: not a function?", this.jsFunctionString), "jsFunction, to string conversion check failed: not a function?"; if (utils.isFunction(e) ? this.jsFunction = e : this.jsFunction = null, this.functionName = t || e && e.name || utils.getFunctionNameFromString(this.jsFunctionString), !this.functionName) throw "jsFunction, missing name argument or value"; if (this.paramNames = utils.getParamNamesFromString(this.jsFunctionString), i) { if (Array.isArray(i)) { if (i.length !== this.paramNames.length) throw "Invalid argument type array length, against function length -> (" + i.length + "," + this.paramNames.length + ")"; this.paramTypes = i } else if ("object" === (void 0 === i ? "undefined" : _typeof(i))) { var s = Object.keys(i); if (i.hasOwnProperty("returns") && (this.returnType = i.returns, s.splice(s.indexOf("returns"), 1)), s.length > 0 && s.length !== this.paramNames.length) throw "Invalid argument type array length, against function length -> (" + s.length + "," + this.paramNames.length + ")"; this.paramTypes = this.paramNames.map(function (t) { return i.hasOwnProperty(t) ? i[t] : "float" }) } } else this.paramTypes = []; this.returnType || (this.returnType = r || "float") } return _createClass(BaseFunctionNode, [{ key: "isIdentifierConstant", value: function (t) { return !!this.constants && this.constants.hasOwnProperty(t) } }, { key: "setAddFunction", value: function (t) { return this.addFunction = t, this } }, { key: "getJsFunction", value: function getJsFunction() { if (this.jsFunction) return this.jsFunction; if (this.jsFunctionString) return this.jsFunction = eval(this.jsFunctionString), this.jsFunction; throw "Missing jsFunction, and jsFunctionString parameter" } }, { key: "astMemberExpressionUnroll", value: function (t, e) { if ("Identifier" === t.type) return t.name; if ("ThisExpression" === t.type) return "this"; if ("MemberExpression" === t.type && t.object && t.property) return t.object.hasOwnProperty("name") && "_" === t.object.name[0] ? this.astMemberExpressionUnroll(t.property, e) : this.astMemberExpressionUnroll(t.object, e) + "." + this.astMemberExpressionUnroll(t.property, e); if (t.hasOwnProperty("expressions")) { var n = t.expressions[0]; if ("Literal" === n.type && 0 === n.value && 2 === t.expressions.length) return this.astMemberExpressionUnroll(t.expressions[1]) } throw this.astErrorOutput("Unknown CallExpression_unroll", t, e) } }, { key: "getJsAST", value: function (t) { if (this.jsFunctionAST) return this.jsFunctionAST; if (null === (t = t || acorn)) throw "Missing JS to AST parser"; var e = t.parse("var " + this.functionName + " = " + this.jsFunctionString + ";", { locations: !0 }); if (null === e) throw "Failed to parse JS code"; var n = e.body[0].declarations[0].init; return this.jsFunctionAST = n, n } }, { key: "getFunctionString", value: function () { return this.generate(), this.functionString } }, { key: "setFunctionString", value: function (t) { this.functionString = t } }, { key: "getParamType", value: function (t) { var e = this.paramNames.indexOf(t); if (-1 === e) return null; if (!this.parent) return null; if (this.paramTypes[e]) return this.paramTypes[e]; for (var n = this.parent.calledFunctionsArguments[this.functionName], i = 0; i < n.length; i++) { var r = n[i]; if (null !== r[e]) return this.paramTypes[e] = r[e].type } return null } }, { key: "getUserParamName", value: function (t) { var e = this.paramNames.indexOf(t); if (-1 === e) return null; if (!this.parent) return null; for (var n = this.parent.calledFunctionsArguments[this.functionName], i = 0; i < n.length; i++) { var r = n[i]; if (null !== r[e]) return r[e].name } return null } }, { key: "generate", value: function (t) { throw new Error("generate not defined on BaseFunctionNode") } }, { key: "astErrorOutput", value: function (t, e, n) { return console.error(utils.getAstString(this.jsFunctionString, e)), console.error(t, e, n), t } }, { key: "astDebuggerStatement", value: function (t, e, n) { return e } }]), BaseFunctionNode }() }, { "../core/utils": 25, acorn: 27 }], 8: [function (t, e, n) { var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); var r = t("../core/utils"); e.exports = function () { function t(e, n) { for (var i in function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.paramNames = r.getParamNamesFromString(e), this.fnString = e, this.output = null, this.debug = !1, this.graphical = !1, this.loopMaxIterations = 0, this.constants = null, this.wraparound = null, this.hardcodeConstants = null, this.outputToTexture = null, this.texSize = null, this._canvas = null, this._webGl = null, this.threadDim = null, this.floatTextures = null, this.floatOutput = null, this.floatOutputForce = null, this.addFunction = null, this.functions = null, this.nativeFunctions = null, this.copyData = !0, this.subKernels = null, this.subKernelProperties = null, this.subKernelNames = null, this.subKernelOutputVariableNames = null, this.functionBuilder = null, this.paramTypes = null, n) n.hasOwnProperty(i) && this.hasOwnProperty(i) && (this[i] = n[i]); n.hasOwnProperty("canvas") && (this._canvas = n.canvas), n.hasOwnProperty("output") && this.setOutput(n.output), this._canvas || (this._canvas = r.initCanvas()) } return i(t, [{ key: "build", value: function () { throw new Error('"build" not defined on Base') } }, { key: "setupParams", value: function (t) { for (var e = this.paramTypes = [], n = 0; n < t.length; n++) { var i = t[n], s = r.getArgumentType(i); e.push(s) } } }, { key: "setAddFunction", value: function (t) { return this.addFunction = t, this } }, { key: "setFunctions", value: function (t) { return this.functions = t, this } }, { key: "setOutput", value: function (t) { return t.hasOwnProperty("x") ? t.hasOwnProperty("y") ? t.hasOwnProperty("z") ? this.output = [t.x, t.y, t.z] : this.output = [t.x, t.y] : this.output = [t.x] : this.output = t, this } }, { key: "setDebug", value: function (t) { return this.debug = t, this } }, { key: "setGraphical", value: function (t) { return this.graphical = t, this } }, { key: "setLoopMaxIterations", value: function (t) { return this.loopMaxIterations = t, this } }, { key: "setConstants", value: function (t) { return this.constants = t, this } }, { key: "setWraparound", value: function (t) { return console.warn("Wraparound mode is not supported and undocumented."), this.wraparound = t, this } }, { key: "setHardcodeConstants", value: function (t) { return this.hardcodeConstants = t, this } }, { key: "setOutputToTexture", value: function (t) { return this.outputToTexture = t, this } }, { key: "setFloatTextures", value: function (t) { return this.floatTextures = t, this } }, { key: "setFloatOutput", value: function (t) { return this.floatOutput = t, this } }, { key: "setFloatOutputForce", value: function (t) { return this.floatOutputForce = t, this } }, { key: "setCanvas", value: function (t) { return this._canvas = t, this } }, { key: "setWebGl", value: function (t) { return this._webGl = t, this } }, { key: "setCopyData", value: function (t) { return this.copyData = t, this } }, { key: "getCanvas", value: function () { return this._canvas } }, { key: "getWebGl", value: function () { return this._webGl } }, { key: "validateOptions", value: function () { throw new Error("validateOptions not defined") } }, { key: "exec", value: function () { return this.execute.apply(this, arguments) } }, { key: "execute", value: function () { var t = this, e = 1 === arguments.length ? [arguments[0]] : Array.apply(null, arguments); return r.newPromise(function (n, i) { try { n(t.run.apply(t, e)) } catch (t) { i(t) } }) } }, { key: "addSubKernel", value: function (t) { return null === this.subKernels && (this.subKernels = [], this.subKernelNames = []), this.subKernels.push(t), this.subKernelNames.push(r.getFunctionNameFromString(t)), this } }, { key: "addSubKernelProperty", value: function (t, e) { if (null === this.subKernelProperties && (this.subKernelProperties = {}, this.subKernelNames = []), this.subKernelProperties.hasOwnProperty(t)) throw new Error("cannot add sub kernel " + t + ", already defined"); return this.subKernelProperties[t] = e, this.subKernelNames.push(r.getFunctionNameFromString(e)), this } }, { key: "addNativeFunction", value: function (t, e) { this.functionBuilder.addNativeFunction(t, e) } }]), t }() }, { "../core/utils": 25 }], 9: [function (t, e, n) { var i = t("../core/utils"); e.exports = function (t) { var e = function () { return t.run.apply(t, arguments) }; return i.allPropertiesOf(t).forEach(function (n) { "_" === n[0] && "_" === n[1] || ("function" == typeof t[n] ? e[n] = "add" === n.substring(0, 3) || "set" === n.substring(0, 3) ? function () { return t[n].apply(t, arguments), e } : t[n].bind(t) : (e.__defineGetter__(n, function () { return t[n] }), e.__defineSetter__(n, function (e) { t[n] = e }))) }), e.kernel = t, e } }, { "../core/utils": 25 }], 10: [function (t, e, n) { var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); var r = t("../core/utils"), s = t("./kernel-run-shortcut"); e.exports = function () { function t(e, n) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), n = n || {}, this.kernel = n.kernel, this.canvas = n.canvas, this.webGl = n.webGl, this.fn = null, this.functionBuilder = e, this.fnString = null, this.endianness = r.systemEndianness(), this.functionBuilder.polyfillStandardFunctions() } return i(t, [{ key: "textureToArray", value: function (t) { return this.createKernel(function (t) { return t[this.thread.z][this.thread.y][this.thread.x] })(t) } }, { key: "deleteTexture", value: function (t) { this.webGl.deleteTexture(t.texture) } }, { key: "buildPromiseKernel", value: function () { throw new Error("not yet implemented") } }, { key: "getMode", value: function () { throw new Error('"mode" not implemented on BaseRunner') } }, { key: "buildKernel", value: function (t, e) { e = Object.assign({}, e || {}); var n = t.toString(); return e.functionBuilder || (e.functionBuilder = this.functionBuilder), e.canvas || (e.canvas = this.canvas), e.webGl || (e.webGl = this.webgl), s(new this.Kernel(n, e)) } }]), t }() }, { "../core/utils": 25, "./kernel-run-shortcut": 9 }], 11: [function (t, e, n) { var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); var r = t("../function-builder-base"), s = t("./function-node"); function a(t) { return Math.floor(t + .5) } e.exports = function (t) { function e() { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, e); var t = function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this)); return t.Node = s, t } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, r), i(e, [{ key: "polyfillStandardFunctions", value: function () { this.addFunction("round", a) } }], [{ key: "round", value: function (t) { return a(t) } }]), e }() }, { "../function-builder-base": 6, "./function-node": 12 }], 12: [function (t, e, n) { var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); var r = t("../function-node-base"), s = t("../../core/utils"), a = /decode32\(\s+encode32\(/g, o = /encode32\(\s+decode32\(/g; e.exports = function (t) { function e() { return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, e), function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)) } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, r), i(e, [{ key: "generate", value: function () { return this.debug && console.log(this), this.prototypeOnly ? e.astFunctionPrototype(this.getJsAST(), [], this).join("").trim() : (this.functionStringArray = this.astGeneric(this.getJsAST(), [], this), this.functionString = this.functionStringArray.join("").trim().replace(a, "((").replace(o, "(("), this.functionString) } }, { key: "astGeneric", value: function (t, e, n) { if (null === t) throw this.astErrorOutput("NULL ast", t, n); if (Array.isArray(t)) { for (var i = 0; i < t.length; i++)this.astGeneric(t[i], e, n); return e } switch (t.type) { case "FunctionDeclaration": return this.astFunctionDeclaration(t, e, n); case "FunctionExpression": return this.astFunctionExpression(t, e, n); case "ReturnStatement": return this.astReturnStatement(t, e, n); case "Literal": return this.astLiteral(t, e, n); case "BinaryExpression": return this.astBinaryExpression(t, e, n); case "Identifier": return this.astIdentifierExpression(t, e, n); case "AssignmentExpression": return this.astAssignmentExpression(t, e, n); case "ExpressionStatement": return this.astExpressionStatement(t, e, n); case "EmptyStatement": return this.astEmptyStatement(t, e, n); case "BlockStatement": return this.astBlockStatement(t, e, n); case "IfStatement": return this.astIfStatement(t, e, n); case "BreakStatement": return this.astBreakStatement(t, e, n); case "ContinueStatement": return this.astContinueStatement(t, e, n); case "ForStatement": return this.astForStatement(t, e, n); case "WhileStatement": return this.astWhileStatement(t, e, n); case "VariableDeclaration": return this.astVariableDeclaration(t, e, n); case "VariableDeclarator": return this.astVariableDeclarator(t, e, n); case "ThisExpression": return this.astThisExpression(t, e, n); case "SequenceExpression": return this.astSequenceExpression(t, e, n); case "UnaryExpression": return this.astUnaryExpression(t, e, n); case "UpdateExpression": return this.astUpdateExpression(t, e, n); case "LogicalExpression": return this.astLogicalExpression(t, e, n); case "MemberExpression": return this.astMemberExpression(t, e, n); case "CallExpression": return this.astCallExpression(t, e, n); case "ArrayExpression": return this.astArrayExpression(t, e, n); case "DebuggerStatement": return this.astDebuggerStatement(t, e, n) }throw this.astErrorOutput("Unknown ast type : " + t.type, t, n) } }, { key: "astFunctionDeclaration", value: function (t, e, n) { return this.addFunction && this.addFunction(null, s.getAstString(this.jsFunctionString, t)), e } }, { key: "astFunctionExpression", value: function (t, e, n) { if (n.isRootKernel ? (e.push("void"), n.kernalAst = t) : e.push(n.returnType), e.push(" "), e.push(n.functionName), e.push("("), !n.isRootKernel) for (var i = 0; i < n.paramNames.length; ++i) { var r = n.paramNames[i]; switch (i > 0 && e.push(", "), n.getParamType(r)) { case "Texture": case "Input": case "Array": e.push("sampler2D"); break; default: e.push("float") }e.push(" "), e.push("user_"), e.push(r) } e.push(") {\n"); for (var s = 0; s < t.body.body.length; ++s)this.astGeneric(t.body.body[s], e, n), e.push("\n"); return e.push("}\n"), e } }, { key: "astReturnStatement", value: function (t, e, n) { return n.isRootKernel ? (e.push("kernelResult = "), this.astGeneric(t.argument, e, n), e.push(";"), e.push("return;")) : n.isSubKernel ? (e.push(n.functionName + "Result = "), this.astGeneric(t.argument, e, n), e.push(";"), e.push("return " + n.functionName + "Result;")) : (e.push("return "), this.astGeneric(t.argument, e, n), e.push(";")), e } }, { key: "astLiteral", value: function (t, e, n) { if (isNaN(t.value)) throw this.astErrorOutput("Non-numeric literal not supported : " + t.value, t, n); return e.push(t.value), Number.isInteger(t.value) && e.push(".0"), e } }, { key: "astBinaryExpression", value: function (t, e, n) { return e.push("("), "%" === t.operator ? (e.push("mod("), this.astGeneric(t.left, e, n), e.push(","), this.astGeneric(t.right, e, n), e.push(")")) : "===" === t.operator ? (this.astGeneric(t.left, e, n), e.push("=="), this.astGeneric(t.right, e, n)) : "!==" === t.operator ? (this.astGeneric(t.left, e, n), e.push("!="), this.astGeneric(t.right, e, n)) : (this.astGeneric(t.left, e, n), e.push(t.operator), this.astGeneric(t.right, e, n)), e.push(")"), e } }, { key: "astIdentifierExpression", value: function (t, e, n) { if ("Identifier" !== t.type) throw this.astErrorOutput("IdentifierExpression - not an Identifier", t, n); switch (t.name) { case "gpu_threadX": e.push("threadId.x"); break; case "gpu_threadY": e.push("threadId.y"); break; case "gpu_threadZ": e.push("threadId.z"); break; case "gpu_outputX": e.push("uOutputDim.x"); break; case "gpu_outputY": e.push("uOutputDim.y"); break; case "gpu_outputZ": e.push("uOutputDim.z"); break; default: if (this.constants && this.constants.hasOwnProperty(t.name)) e.push("constants_" + t.name); else { var i = n.getUserParamName(t.name); null !== i ? e.push("user_" + i) : e.push("user_" + t.name) } }return e } }, { key: "astForStatement", value: function (t, e, n) { if ("ForStatement" !== t.type) throw this.astErrorOutput("Invalid for statment", t, n); if (t.test && "BinaryExpression" === t.test.type) { if ("Identifier" === t.test.right.type && "<" === t.test.operator && !1 === this.isIdentifierConstant(t.test.right.name)) { if (this.loopMaxIterations || (console.warn("Warning: loopMaxIterations is not set! Using default of 1000 which may result in unintended behavior."), console.warn("Set loopMaxIterations or use a for loop of fixed length to silence this message.")), e.push("for ("), this.astGeneric(t.init, e, n), this.astGeneric(t.test.left, e, n), e.push(t.test.operator), e.push("LOOP_MAX"), e.push(";"), this.astGeneric(t.update, e, n), e.push(")"), e.push("{\n"), e.push("if ("), this.astGeneric(t.test.left, e, n), e.push(t.test.operator), this.astGeneric(t.test.right, e, n), e.push(") {\n"), "BlockStatement" === t.body.type) for (var i = 0; i < t.body.body.length; i++)this.astGeneric(t.body.body[i], e, n); else this.astGeneric(t.body, e, n); return e.push("} else {\n"), e.push("break;\n"), e.push("}\n"), e.push("}\n"), e } var r = JSON.parse(JSON.stringify(t.init.declarations)), s = t.update.argument; if (!Array.isArray(r) || r.length < 1) throw console.log(this.jsFunctionString), new Error("Error: Incompatible for loop declaration"); if (r.length > 1) { for (var a = null, o = 0; o < r.length; o++) { var u = r[o]; u.id.name === s.name ? (a = u, r.splice(o, 1)) : (e.push("float "), this.astGeneric(u, e, n), e.push(";")) } e.push("for (float "), this.astGeneric(a, e, n), e.push(";") } else e.push("for ("), this.astGeneric(t.init, e, n); return this.astGeneric(t.test, e, n), e.push(";"), this.astGeneric(t.update, e, n), e.push(")"), this.astGeneric(t.body, e, n), e } throw this.astErrorOutput("Invalid for statement", t, n) } }, { key: "astWhileStatement", value: function (t, e, n) { if ("WhileStatement" !== t.type) throw this.astErrorOutput("Invalid while statment", t, n); return e.push("for (float i = 0.0; i < LOOP_MAX; i++) {"), e.push("if ("), this.astGeneric(t.test, e, n), e.push(") {\n"), this.astGeneric(t.body, e, n), e.push("} else {\n"), e.push("break;\n"), e.push("}\n"), e.push("}\n"), e } }, { key: "astAssignmentExpression", value: function (t, e, n) { if ("%=" !== t.operator) return this.astGeneric(t.left, e, n), e.push(t.operator), this.astGeneric(t.right, e, n), e; this.astGeneric(t.left, e, n), e.push("="), e.push("mod("), this.astGeneric(t.left, e, n), e.push(","), this.astGeneric(t.right, e, n), e.push(")") } }, { key: "astEmptyStatement", value: function (t, e, n) { return e } }, { key: "astBlockStatement", value: function (t, e, n) { e.push("{\n"); for (var i = 0; i < t.body.length; i++)this.astGeneric(t.body[i], e, n); return e.push("}\n"), e } }, { key: "astExpressionStatement", value: function (t, e, n) { return this.astGeneric(t.expression, e, n), e.push(";\n"), e } }, { key: "astVariableDeclaration", value: function (t, e, n) { e.push("float "); for (var i = 0; i < t.declarations.length; i++)i > 0 && e.push(","), this.astGeneric(t.declarations[i], e, n); return e.push(";"), e } }, { key: "astVariableDeclarator", value: function (t, e, n) { return this.astGeneric(t.id, e, n), null !== t.init && (e.push("="), this.astGeneric(t.init, e, n)), e } }, { key: "astIfStatement", value: function (t, e, n) { return e.push("if ("), this.astGeneric(t.test, e, n), e.push(")"), "BlockStatement" === t.consequent.type ? this.astGeneric(t.consequent, e, n) : (e.push(" {\n"), this.astGeneric(t.consequent, e, n), e.push("\n}\n")), t.alternate && (e.push("else "), "BlockStatement" === t.alternate.type ? this.astGeneric(t.alternate, e, n) : (e.push(" {\n"), this.astGeneric(t.alternate, e, n), e.push("\n}\n"))), e } }, { key: "astBreakStatement", value: function (t, e, n) { return e.push("break;\n"), e } }, { key: "astContinueStatement", value: function (t, e, n) { return e.push("continue;\n"), e } }, { key: "astLogicalExpression", value: function (t, e, n) { return e.push("("), this.astGeneric(t.left, e, n), e.push(t.operator), this.astGeneric(t.right, e, n), e.push(")"), e } }, { key: "astUpdateExpression", value: function (t, e, n) { return t.prefix ? (e.push(t.operator), this.astGeneric(t.argument, e, n)) : (this.astGeneric(t.argument, e, n), e.push(t.operator)), e } }, { key: "astUnaryExpression", value: function (t, e, n) { return t.prefix ? (e.push(t.operator), this.astGeneric(t.argument, e, n)) : (this.astGeneric(t.argument, e, n), e.push(t.operator)), e } }, { key: "astThisExpression", value: function (t, e, n) { return e.push("this"), e } }, { key: "astMemberExpression", value: function (t, e, n) { if (t.computed) if ("Identifier" === t.object.type) { var i = t.object.name, r = (n.functionName, !1); if (n.paramNames) { var s = n.paramNames.indexOf(i); s >= 0 && "float" === n.paramTypes[s] && (r = !0) } r ? (this.astGeneric(t.object, e, n), e.push("[int("), this.astGeneric(t.property, e, n), e.push(")]")) : (e.push("get("), this.astGeneric(t.object, e, n), e.push(", vec2("), this.astGeneric(t.object, e, n), e.push("Size[0],"), this.astGeneric(t.object, e, n), e.push("Size[1]), vec3("), this.astGeneric(t.object, e, n), e.push("Dim[0],"), this.astGeneric(t.object, e, n), e.push("Dim[1],"), this.astGeneric(t.object, e, n), e.push("Dim[2]"), e.push("), "), this.astGeneric(t.property, e, n), e.push(")")) } else { this.astGeneric(t.object, e, n); var a = e.pop(); e.push(","), this.astGeneric(t.property, e, n), e.push(a) } else { var o = this.astMemberExpressionUnroll(t), u = o.toLowerCase(); switch (0 === o.indexOf("this.constants.") && (o = "constants_" + o.slice("this.constants.".length)), u) { case "this.thread.x": e.push("threadId.x"); break; case "this.thread.y": e.push("threadId.y"); break; case "this.thread.z": e.push("threadId.z"); break; case "this.output.x": e.push(this.output[0] + ".0"); break; case "this.output.y": e.push(this.output[1] + ".0"); break; case "this.output.z": e.push(this.output[2] + ".0"); break; default: e.push(o) } } return e } }, { key: "astSequenceExpression", value: function (t, e, n) { for (var i = 0; i < t.expressions.length; i++)i > 0 && e.push(","), this.astGeneric(t.expressions, e, n); return e } }, { key: "astCallExpression", value: function (t, e, n) { if (t.callee) { var i = this.astMemberExpressionUnroll(t.callee); 0 === i.indexOf("Math.") && (i = i.slice("Math.".length)), 0 === i.indexOf("this.") && (i = i.slice("this.".length)), n.calledFunctions.indexOf(i) < 0 && n.calledFunctions.push(i), n.hasOwnProperty("funcName") || (n.calledFunctionsArguments[i] = []); var r = []; n.calledFunctionsArguments[i].push(r), e.push(i), e.push("("); for (var s = 0; s < t.arguments.length; ++s) { var a = t.arguments[s]; if (s > 0 && e.push(", "), this.astGeneric(a, e, n), "Identifier" === a.type) { var o = n.paramNames.indexOf(a.name); -1 === o ? r.push(null) : r.push({ name: a.name, type: n.paramTypes[o] }) } else r.push(null) } return e.push(")"), e } throw this.astErrorOutput("Unknown CallExpression", t, n) } }, { key: "astArrayExpression", value: function (t, e, n) { var i = t.elements.length; e.push("float[" + i + "]("); for (var r = 0; r < i; ++r) { r > 0 && e.push(", "); var s = t.elements[r]; this.astGeneric(s, e, n) } return e.push(")"), e } }, { key: "getFunctionPrototypeString", value: function () { return this.webGlFunctionPrototypeString ? this.webGlFunctionPrototypeString : this.webGlFunctionPrototypeString = this.generate() } }, { key: "build", value: function () { return this.getFunctionPrototypeString().length > 0 } }], [{ key: "astFunctionPrototype", value: function (t, e, n) { if (n.isRootKernel || n.isSubKernel) return e; e.push(n.returnType), e.push(" "), e.push(n.functionName), e.push("("); for (var i = 0; i < n.paramNames.length; ++i)i > 0 && e.push(", "), e.push(n.paramTypes[i]), e.push(" "), e.push("user_"), e.push(n.paramNames[i]); return e.push(");\n"), e } }]), e }() }, { "../../core/utils": 25, "../function-node-base": 7 }], 13: [function (t, e, n) { var i = t("../../core/utils"), r = t("../kernel-run-shortcut"); e.exports = function (t, e) { return "() => {\n    " + r.toString() + ";\n    const utils = {\n      allPropertiesOf: function " + i.allPropertiesOf.toString() + ",\n      clone: function " + i.clone.toString() + ",\n      splitArray: function " + i.splitArray.toString() + ",\n      getArgumentType: function " + i.getArgumentType.toString() + ",\n      getDimensions: function " + i.getDimensions.toString() + ",\n      dimToTexSize: function " + i.dimToTexSize.toString() + ",\n      copyFlatten: function " + i.copyFlatten.toString() + ",\n      flatten: function " + i.flatten.toString() + ",\n      systemEndianness: '" + i.systemEndianness() + "',\n      initWebGl: function " + i.initWebGl.toString() + ",\n      isArray: function " + i.isArray.toString() + "\n    };\n    class " + (e || "Kernel") + " {\n      constructor() {\n        this.argumentsLength = 0;\n        this._canvas = null;\n        this._webGl = null;\n        this.built = false;\n        this.program = null;\n        this.paramNames = " + JSON.stringify(t.paramNames) + ";\n        this.paramTypes = " + JSON.stringify(t.paramTypes) + ";\n        this.texSize = " + JSON.stringify(t.texSize) + ";\n        this.output = " + JSON.stringify(t.output) + ";\n        this.compiledFragShaderString = `" + t.compiledFragShaderString + "`;\n\t\t    this.compiledVertShaderString = `" + t.compiledVertShaderString + "`;\n\t\t    this.programUniformLocationCache = {};\n\t\t    this.textureCache = {};\n\t\t    this.subKernelOutputTextures = null;\n      }\n      " + t._getFragShaderString.toString() + "\n      " + t._getVertShaderString.toString() + "\n      validateOptions() {}\n      setupParams() {}\n      setCanvas(canvas) { this._canvas = canvas; return this; }\n      setWebGl(webGl) { this._webGl = webGl; return this; }\n      " + t.getUniformLocation.toString() + "\n      " + t.setupParams.toString() + "\n      " + t.build.toString() + "\n\t\t  " + t.run.toString() + "\n\t\t  " + t._addArgument.toString() + "\n\t\t  " + t.getArgumentTexture.toString() + "\n\t\t  " + t.getTextureCache.toString() + "\n\t\t  " + t.getOutputTexture.toString() + "\n\t\t  " + t.renderOutput.toString() + "\n    };\n    return kernelRunShortcut(new Kernel());\n  };" } }, { "../../core/utils": 25, "../kernel-run-shortcut": 9 }], 14: [function (t, e, n) { var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); var r = t("../kernel-base"), s = t("../../core/utils"), a = t("../../core/texture"), o = t("./shader-frag"), u = t("./shader-vert"), h = t("./kernel-string"), l = [], p = {}; e.exports = function (t) { function e(t, n) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, e); var i = function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)); return i.textureCache = {}, i.threadDim = {}, i.programUniformLocationCache = {}, i.framebuffer = null, i.buffer = null, i.program = null, i.outputToTexture = n.outputToTexture, i.endianness = s.systemEndianness(), i.subKernelOutputTextures = null, i.subKernelOutputVariableNames = null, i.argumentsLength = 0, i.ext = null, i.compiledFragShaderString = null, i.compiledVertShaderString = null, i.extDrawBuffersMap = null, i.outputTexture = null, i.maxTexSize = null, i._webGl || (i._webGl = s.initWebGl(i.getCanvas())), i } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, r), i(e, [{ key: "validateOptions", value: function () { var t = s.isFloatReadPixelsSupported(); if (!0 === this.floatTextures && !s.OES_texture_float) throw new Error("Float textures are not supported on this browser"); if (!0 === this.floatOutput && !0 !== this.floatOutputForce && !t) throw new Error("Float texture outputs are not supported on this browser"); if (void 0 === this.floatTextures && s.OES_texture_float && (this.floatTextures = !0, this.floatOutput = t), !this.output || 0 === this.output.length) { if (1 !== arguments.length) throw new Error("Auto output only supported for kernels with only one input"); var e = s.getArgumentType(arguments[0]); if ("Array" === e) this.output = s.getDimensions(e); else { if ("Texture" !== e) throw new Error("Auto output not supported for input type: " + e); this.output = arguments[0].output } } if (this.texSize = s.dimToTexSize({ floatTextures: this.floatTextures, floatOutput: this.floatOutput }, this.output, !0), this.graphical) { if (2 !== this.output.length) throw new Error("Output must have 2 dimensions on graphical mode"); this.floatOutput && (this.floatOutput = !1, console.warn("Cannot use graphical mode and float output at the same time")), this.texSize = s.clone(this.output) } else void 0 === this.floatOutput && s.OES_texture_float && (this.floatOutput = !0) } }, { key: "updateMaxTexSize", value: function () { var t = this.texSize, e = this._canvas; if (null === this.maxTexSize) { var n = l.indexOf(e); -1 === n && (n = l.length, l.push(e), p[n] = [t[0], t[1]]), this.maxTexSize = p[n] } this.maxTexSize[0] < t[0] && (this.maxTexSize[0] = t[0]), this.maxTexSize[1] < t[1] && (this.maxTexSize[1] = t[1]) } }, { key: "build", value: function () { this.validateOptions(), this.setupParams(arguments), this.updateMaxTexSize(); var t = this.texSize, e = this._webGl, n = this._canvas; e.enable(e.SCISSOR_TEST), e.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]), n.width = this.maxTexSize[0], n.height = this.maxTexSize[1]; for (var i = this.threadDim = s.clone(this.output); i.length < 3;)i.push(1); this.functionBuilder && this._addKernels(); var r = this._getVertShaderString(arguments), a = e.createShader(e.VERTEX_SHADER); e.shaderSource(a, r), e.compileShader(a); var o = this._getFragShaderString(arguments), u = e.createShader(e.FRAGMENT_SHADER); if (e.shaderSource(u, o), e.compileShader(u), !e.getShaderParameter(a, e.COMPILE_STATUS)) throw console.log(r), console.error("An error occurred compiling the shaders: " + e.getShaderInfoLog(a)), new Error("Error compiling vertex shader"); if (!e.getShaderParameter(u, e.COMPILE_STATUS)) throw console.log(o), console.error("An error occurred compiling the shaders: " + e.getShaderInfoLog(u)), new Error("Error compiling fragment shader"); this.debug && (console.log("Options:"), console.dir(this), console.log("GLSL Shader Output:"), console.log(o)); var h = this.program = e.createProgram(); e.attachShader(h, a), e.attachShader(h, u), e.linkProgram(h), this.framebuffer = e.createFramebuffer(), this.framebuffer.width = t[0], this.framebuffer.height = t[1]; var l = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), p = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), c = l.byteLength, f = this.buffer; f ? e.bindBuffer(e.ARRAY_BUFFER, f) : (f = this.buffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, f), e.bufferData(e.ARRAY_BUFFER, l.byteLength + p.byteLength, e.STATIC_DRAW)), e.bufferSubData(e.ARRAY_BUFFER, 0, l), e.bufferSubData(e.ARRAY_BUFFER, c, p); var d = e.getAttribLocation(this.program, "aPos"); e.enableVertexAttribArray(d), e.vertexAttribPointer(d, 2, e.FLOAT, e.FALSE, 0, 0); var m = e.getAttribLocation(this.program, "aTexCoord"); if (e.enableVertexAttribArray(m), e.vertexAttribPointer(m, 2, e.FLOAT, e.FALSE, 0, c), this.setupOutputTexture(), null !== this.subKernelOutputTextures) for (var g = this.extDrawBuffersMap = [e.COLOR_ATTACHMENT0], y = 0; y < this.subKernelOutputTextures.length; y++) { var v = this.subKernelOutputTextures[y]; g.push(e.COLOR_ATTACHMENT0 + y + 1), e.activeTexture(e.TEXTURE0 + arguments.length + y), e.bindTexture(e.TEXTURE_2D, v), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), this.floatOutput ? e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, t[0], t[1], 0, e.RGBA, e.FLOAT, null) : e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, t[0], t[1], 0, e.RGBA, e.UNSIGNED_BYTE, null) } } }, { key: "run", value: function () { null === this.program && this.build.apply(this, arguments); var t = this.paramNames, e = this.paramTypes, n = this.texSize, i = this._webGl; if (i.useProgram(this.program), i.scissor(0, 0, n[0], n[1]), !this.hardcodeConstants) { var r = this.getUniformLocation("uOutputDim"); i.uniform3fv(r, this.threadDim); var s = this.getUniformLocation("uTexSize"); i.uniform2fv(s, n) } var o = this.getUniformLocation("ratio"); i.uniform2f(o, n[0] / this.maxTexSize[0], n[1] / this.maxTexSize[1]), this.argumentsLength = 0; for (var u = 0; u < t.length; u++)this._addArgument(arguments[u], e[u], t[u]); if (this.graphical) return i.bindRenderbuffer(i.RENDERBUFFER, null), i.bindFramebuffer(i.FRAMEBUFFER, null), void i.drawArrays(i.TRIANGLE_STRIP, 0, 4); i.bindFramebuffer(i.FRAMEBUFFER, this.framebuffer); var h = this.outputTexture; if (i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, h, 0), null !== this.subKernelOutputTextures) { for (var l = 0; l < this.subKernelOutputTextures.length; l++) { var p = this.subKernelOutputTextures[l]; i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + l + 1, i.TEXTURE_2D, p, 0) } this.ext.drawBuffersWEBGL(this.extDrawBuffersMap) } if (i.drawArrays(i.TRIANGLE_STRIP, 0, 4), null !== this.subKernelOutputTextures) { if (null !== this.subKernels) { var c = []; c.result = this.renderOutput(h); for (var f = 0; f < this.subKernels.length; f++)c.push(new a(this.subKernelOutputTextures[f], n, this.output, this._webGl)); return c } if (null !== this.subKernelProperties) { var d = { result: this.renderOutput(h) }, m = 0; for (var g in this.subKernelProperties) this.subKernelProperties.hasOwnProperty(g) && (d[g] = new a(this.subKernelOutputTextures[m], n, this.output, this._webGl), m++); return d } } return this.renderOutput(h) } }, { key: "renderOutput", value: function (t) { var e = this.texSize, n = this._webGl, i = this.threadDim, r = this.output; if (this.outputToTexture) return new a(t, e, r, this._webGl); var o = void 0; if (this.floatOutput) o = new Float32Array(e[0] * e[1] * 4), n.readPixels(0, 0, e[0], e[1], n.RGBA, n.FLOAT, o); else { var u = new Uint8Array(e[0] * e[1] * 4); n.readPixels(0, 0, e[0], e[1], n.RGBA, n.UNSIGNED_BYTE, u), o = new Float32Array(u.buffer) } return o = o.subarray(0, i[0] * i[1] * i[2]), 1 === r.length ? o : 2 === r.length ? s.splitArray(o, r[0]) : 3 === r.length ? s.splitArray(o, r[0] * r[1]).map(function (t) { return s.splitArray(t, r[0]) }) : void 0 } }, { key: "getOutputTexture", value: function () { return this.getTextureCache("OUTPUT") } }, { key: "detachOutputTexture", value: function () { this.detachTextureCache("OUTPUT") } }, { key: "setupOutputTexture", value: function () { var t = this._webGl, e = this.texSize; this.detachOutputTexture(), this.outputTexture = this.getOutputTexture(), t.activeTexture(t.TEXTURE0 + this.paramNames.length), t.bindTexture(t.TEXTURE_2D, this.outputTexture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), this.floatOutput ? t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e[0], e[1], 0, t.RGBA, t.FLOAT, null) : t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e[0], e[1], 0, t.RGBA, t.UNSIGNED_BYTE, null) } }, { key: "getArgumentTexture", value: function (t) { return this.getTextureCache("ARGUMENT_" + t) } }, { key: "getSubKernelTexture", value: function (t) { return this.getTextureCache("SUB_KERNEL_" + t) } }, { key: "getTextureCache", value: function (t) { return this.outputToTexture ? this._webGl.createTexture() : this.textureCache.hasOwnProperty(t) ? this.textureCache[t] : this.textureCache[t] = this._webGl.createTexture() } }, { key: "detachTextureCache", value: function (t) { delete this.textureCache[t] } }, { key: "getUniformLocation", value: function (t) { var e = this.programUniformLocationCache[t]; return e || (e = this._webGl.getUniformLocation(this.program, t), this.programUniformLocationCache[t] = e), e } }, { key: "_getFragShaderArtifactMap", value: function (t) { return { HEADER: this._getHeaderString(), LOOP_MAX: this._getLoopMaxString(), CONSTANTS: this._getConstantsString(), DECODE32_ENDIANNESS: this._getDecode32EndiannessString(), ENCODE32_ENDIANNESS: this._getEncode32EndiannessString(), GET_WRAPAROUND: this._getGetWraparoundString(), GET_TEXTURE_CHANNEL: this._getGetTextureChannelString(), GET_TEXTURE_INDEX: this._getGetTextureIndexString(), GET_RESULT: this._getGetResultString(), MAIN_PARAMS: this._getMainParamsString(t), MAIN_CONSTANTS: this._getMainConstantsString(), KERNEL: this._getKernelString(), MAIN_RESULT: this._getMainResultString() } } }, { key: "_addArgument", value: function (t, e, n) { var i = this._webGl, r = this.getArgumentTexture(n); switch (t instanceof a && (e = "Texture"), e) { case "Array": var o = s.getDimensions(t, !0), u = s.dimToTexSize({ floatTextures: this.floatTextures, floatOutput: this.floatOutput }, o); i.activeTexture(i.TEXTURE0 + this.argumentsLength), i.bindTexture(i.TEXTURE_2D, r), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.NEAREST); var h = u[0] * u[1]; this.floatTextures && (h *= 4); var l = new Float32Array(h); s.flattenTo(t, l); var p = void 0; this.floatTextures ? i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, u[0], u[1], 0, i.RGBA, i.FLOAT, l) : (p = new Uint8Array(l.buffer), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, u[0], u[1], 0, i.RGBA, i.UNSIGNED_BYTE, p)); var c = this.getUniformLocation("user_" + n), f = this.getUniformLocation("user_" + n + "Size"), d = this.getUniformLocation("user_" + n + "Dim"); this.hardcodeConstants || (i.uniform3fv(d, o), i.uniform2fv(f, u)), i.uniform1i(c, this.argumentsLength); break; case "Number": var m = this.getUniformLocation("user_" + n); i.uniform1f(m, t); break; case "Input": var g = t, y = g.size, v = s.dimToTexSize({ floatTextures: this.floatTextures, floatOutput: this.floatOutput }, y); i.activeTexture(i.TEXTURE0 + this.argumentsLength), i.bindTexture(i.TEXTURE_2D, r), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.NEAREST); var b = v[0] * v[1], x = void 0; if (this.floatTextures ? (x = new Float32Array(b *= 4)).set(g.value) : x = g.value, this.floatTextures) i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, v[0], v[1], 0, i.RGBA, i.FLOAT, x); else { var k = new Uint8Array(x.buffer); i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, v[0], v[1], 0, i.RGBA, i.UNSIGNED_BYTE, k) } var E = this.getUniformLocation("user_" + n), S = this.getUniformLocation("user_" + n + "Size"), _ = this.getUniformLocation("user_" + n + "Dim"); this.hardcodeConstants || (i.uniform3fv(_, y), i.uniform2fv(S, v)), i.uniform1i(E, this.argumentsLength); break; case "Texture": var w = t, T = s.getDimensions(w, !0), A = w.size; w.texture === this.outputTexture && this.setupOutputTexture(), i.activeTexture(i.TEXTURE0 + this.argumentsLength), i.bindTexture(i.TEXTURE_2D, w.texture); var O = this.getUniformLocation("user_" + n), N = this.getUniformLocation("user_" + n + "Size"), P = this.getUniformLocation("user_" + n + "Dim"); i.uniform3fv(P, T), i.uniform2fv(N, A), i.uniform1i(O, this.argumentsLength); break; default: throw new Error("Input type not supported (WebGL): " + t) }this.argumentsLength++ } }, { key: "_getHeaderString", value: function () { return null !== this.subKernels || null !== this.subKernelProperties ? "#extension GL_EXT_draw_buffers : require\n" : "" } }, { key: "_getLoopMaxString", value: function () { return this.loopMaxIterations ? " " + parseInt(this.loopMaxIterations) + ".0;\n" : " 1000.0;\n" } }, { key: "_getConstantsString", value: function () { var t = [], e = this.threadDim, n = this.texSize; return this.hardcodeConstants ? t.push("highp vec3 uOutputDim = vec3(" + e[0] + "," + e[1] + ", " + e[2] + ")", "highp vec2 uTexSize = vec2(" + n[0] + ", " + n[1] + ")") : t.push("uniform highp vec3 uOutputDim", "uniform highp vec2 uTexSize"), this._linesToString(t) } }, { key: "_getTextureCoordinate", value: function () { var t = this.subKernelOutputVariableNames; return null === t || t.length < 1 ? "varying highp vec2 vTexCoord;\n" : "out highp vec2 vTexCoord;\n" } }, { key: "_getDecode32EndiannessString", value: function () { return "LE" === this.endianness ? "" : "  rgba.rgba = rgba.abgr;\n" } }, { key: "_getEncode32EndiannessString", value: function () { return "LE" === this.endianness ? "" : "  rgba.rgba = rgba.abgr;\n" } }, { key: "_getGetWraparoundString", value: function () { return this.wraparound ? "  xyz = mod(xyz, texDim);\n" : "" } }, { key: "_getGetTextureChannelString", value: function () { return this.floatTextures ? this._linesToString(["  int channel = int(integerMod(index, 4.0))", "  index = float(int(index) / 4)"]) : "" } }, { key: "_getGetTextureIndexString", value: function () { return this.floatTextures ? "  index = float(int(index)/4);\n" : "" } }, { key: "_getGetResultString", value: function () { return this.floatTextures ? this._linesToString(["  if (channel == 0) return texel.r", "  if (channel == 1) return texel.g", "  if (channel == 2) return texel.b", "  if (channel == 3) return texel.a"]) : "  return decode32(texel);\n" } }, { key: "_getMainParamsString", value: function (t) { for (var e = [], n = this.paramTypes, i = this.paramNames, r = 0; r < i.length; r++) { var a = t[r], o = i[r], u = n[r]; if (this.hardcodeConstants) if ("Array" === u || "Texture" === u) { var h = s.getDimensions(a, !0), l = s.dimToTexSize({ floatTextures: this.floatTextures, floatOutput: this.floatOutput }, h); e.push("uniform highp sampler2D user_" + o, "highp vec2 user_" + o + "Size = vec2(" + l[0] + ".0, " + l[1] + ".0)", "highp vec3 user_" + o + "Dim = vec3(" + h[0] + ".0, " + h[1] + ".0, " + h[2] + ".0)") } else "Number" === u && Number.isInteger(a) ? e.push("highp float user_" + o + " = " + a + ".0") : "Number" === u && e.push("highp float user_" + o + " = " + a); else "Array" === u || "Texture" === u || "Input" === u ? e.push("uniform highp sampler2D user_" + o, "uniform highp vec2 user_" + o + "Size", "uniform highp vec3 user_" + o + "Dim") : "Number" === u && e.push("uniform highp float user_" + o) } return this._linesToString(e) } }, { key: "_getMainConstantsString", value: function () { var t = []; if (this.constants) for (var e in this.constants) if (this.constants.hasOwnProperty(e)) { var n = parseFloat(this.constants[e]); Number.isInteger(n) ? t.push("const float constants_" + e + " = " + parseInt(n) + ".0") : t.push("const float constants_" + e + " = " + parseFloat(n)) } return this._linesToString(t) } }, { key: "_getKernelString", value: function () { var t = [], e = this.subKernelOutputVariableNames; if (null !== e) { t.push("highp float kernelResult = 0.0"); for (var n = 0; n < e.length; n++)t.push("highp float " + e[n] + " = 0.0") } else t.push("highp float kernelResult = 0.0"); return this._linesToString(t) + this.functionBuilder.getPrototypeString("kernel") } }, { key: "_getMainResultString", value: function () { var t = this.subKernelOutputVariableNames, e = []; if (this.floatOutput && e.push("  index *= 4.0"), this.graphical) e.push("  threadId = indexTo3D(index, uOutputDim)", "  kernel()", "  gl_FragColor = actualColor"); else if (this.floatOutput) for (var n = ["r", "g", "b", "a"], i = 0; i < n.length; ++i) { if (e.push("  threadId = indexTo3D(index, uOutputDim)"), e.push("  kernel()"), t) { e.push("  gl_FragData[0]." + n[i] + " = kernelResult"); for (var r = 0; r < t.length; ++r)e.push("  gl_FragData[" + (r + 1) + "]." + n[i] + " = " + t[r]) } else e.push("  gl_FragColor." + n[i] + " = kernelResult"); i < n.length - 1 && e.push("  index += 1.0") } else if (null !== t) { e.push("  threadId = indexTo3D(index, uOutputDim)"), e.push("  kernel()"), e.push("  gl_FragData[0] = encode32(kernelResult)"); for (var s = 0; s < t.length; s++)e.push("  gl_FragData[" + (s + 1) + "] = encode32(" + t[s] + ")") } else e.push("  threadId = indexTo3D(index, uOutputDim)", "  kernel()", "  gl_FragColor = encode32(kernelResult)"); return this._linesToString(e) } }, { key: "_linesToString", value: function (t) { return t.length > 0 ? t.join(";\n") + ";\n" : "\n" } }, { key: "_replaceArtifacts", value: function (t, e) { return t.replace(/[ ]*__([A-Z]+[0-9]*([_]?[A-Z])*)__;\n/g, function (t, n) { if (e.hasOwnProperty(n)) return e[n]; throw "unhandled artifact " + n }) } }, { key: "_addKernels", value: function () { var t = this.functionBuilder, e = this._webGl; if (t.addFunctions(this.functions, { constants: this.constants, output: this.output }), t.addNativeFunctions(this.nativeFunctions), t.addKernel(this.fnString, { prototypeOnly: !1, constants: this.constants, output: this.output, debug: this.debug, loopMaxIterations: this.loopMaxIterations }, this.paramNames, this.paramTypes), null !== this.subKernels) { if (!(this.ext = e.getExtension("WEBGL_draw_buffers"))) throw new Error("could not instantiate draw buffers extension"); this.subKernelOutputTextures = [], this.subKernelOutputVariableNames = []; for (var n = 0; n < this.subKernels.length; n++) { var i = this.subKernels[n]; t.addSubKernel(i, { prototypeOnly: !1, constants: this.constants, output: this.output, debug: this.debug, loopMaxIterations: this.loopMaxIterations }), this.subKernelOutputTextures.push(this.getSubKernelTexture(n)), this.subKernelOutputVariableNames.push(i.name + "Result") } } else if (null !== this.subKernelProperties) { if (!(this.ext = e.getExtension("WEBGL_draw_buffers"))) throw new Error("could not instantiate draw buffers extension"); this.subKernelOutputTextures = [], this.subKernelOutputVariableNames = []; for (var r in this.subKernelProperties) if (this.subKernelProperties.hasOwnProperty(r)) { var s = this.subKernelProperties[r]; t.addSubKernel(s, { prototypeOnly: !1, constants: this.constants, output: this.output, debug: this.debug, loopMaxIterations: this.loopMaxIterations }), this.subKernelOutputTextures.push(this.getSubKernelTexture(r)), this.subKernelOutputVariableNames.push(s.name + "Result"), 0 } } } }, { key: "_getFragShaderString", value: function (t) { return null !== this.compiledFragShaderString ? this.compiledFragShaderString : this.compiledFragShaderString = this._replaceArtifacts(o, this._getFragShaderArtifactMap(t)) } }, { key: "_getVertShaderString", value: function (t) { return null !== this.compiledVertShaderString ? this.compiledVertShaderString : this.compiledVertShaderString = u } }, { key: "toString", value: function () { return h(this) } }, { key: "addFunction", value: function (t) { this.functionBuilder.addFunction(null, t) } }]), e }() }, { "../../core/texture": 23, "../../core/utils": 25, "../kernel-base": 8, "./kernel-string": 13, "./shader-frag": 16, "./shader-vert": 17 }], 15: [function (t, e, n) { var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); var r = t("../runner-base"), s = t("./kernel"), a = (t("../../core/utils"), t("./function-builder")); e.exports = function (t) { function e(t) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, e); var n = function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, new a, t)); return n.Kernel = s, n.kernel = null, n } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, r), i(e, [{ key: "getMode", value: function () { return "gpu" } }]), e }() }, { "../../core/utils": 25, "../runner-base": 10, "./function-builder": 11, "./kernel": 14 }], 16: [function (t, e, n) { e.exports = "__HEADER__;\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\nconst float LOOP_MAX = __LOOP_MAX__;\n#define EPSILON 0.0000001;\n\n__CONSTANTS__;\n\nvarying highp vec2 vTexCoord;\n\nvec4 round(vec4 x) {\n  return floor(x + 0.5);\n}\n\nhighp float round(highp float x) {\n  return floor(x + 0.5);\n}\n\nvec2 integerMod(vec2 x, float y) {\n  vec2 res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nvec3 integerMod(vec3 x, float y) {\n  vec3 res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nvec4 integerMod(vec4 x, vec4 y) {\n  vec4 res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nhighp float integerMod(highp float x, highp float y) {\n  highp float res = floor(mod(x, y));\n  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);\n}\n\nhighp int integerMod(highp int x, highp int y) {\n  return int(integerMod(float(x), float(y)));\n}\n\n// Here be dragons!\n// DO NOT OPTIMIZE THIS CODE\n// YOU WILL BREAK SOMETHING ON SOMEBODY'S MACHINE\n// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME\nconst vec2 MAGIC_VEC = vec2(1.0, -256.0);\nconst vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);\nconst vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536\nhighp float decode32(highp vec4 rgba) {\n  __DECODE32_ENDIANNESS__;\n  rgba *= 255.0;\n  vec2 gte128;\n  gte128.x = rgba.b >= 128.0 ? 1.0 : 0.0;\n  gte128.y = rgba.a >= 128.0 ? 1.0 : 0.0;\n  float exponent = 2.0 * rgba.a - 127.0 + dot(gte128, MAGIC_VEC);\n  float res = exp2(round(exponent));\n  rgba.b = rgba.b - 128.0 * gte128.x;\n  res = dot(rgba, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;\n  res *= gte128.y * -2.0 + 1.0;\n  return res;\n}\n\nhighp vec4 encode32(highp float f) {\n  highp float F = abs(f);\n  highp float sign = f < 0.0 ? 1.0 : 0.0;\n  highp float exponent = floor(log2(F));\n  highp float mantissa = (exp2(-exponent) * F);\n  // exponent += floor(log2(mantissa));\n  vec4 rgba = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;\n  rgba.rg = integerMod(rgba.rg, 256.0);\n  rgba.b = integerMod(rgba.b, 128.0);\n  rgba.a = exponent*0.5 + 63.5;\n  rgba.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;\n  rgba = floor(rgba);\n  rgba *= 0.003921569; // 1/255\n  __ENCODE32_ENDIANNESS__;\n  return rgba;\n}\n// Dragons end here\n\nhighp float index;\nhighp vec3 threadId;\n\nhighp vec3 indexTo3D(highp float idx, highp vec3 texDim) {\n  highp float z = floor(idx / (texDim.x * texDim.y));\n  idx -= z * texDim.x * texDim.y;\n  highp float y = floor(idx / texDim.x);\n  highp float x = integerMod(idx, texDim.x);\n  return vec3(x, y, z);\n}\n\nhighp float get(highp sampler2D tex, highp vec2 texSize, highp vec3 texDim, highp float z, highp float y, highp float x) {\n  highp vec3 xyz = vec3(x, y, z);\n  xyz = floor(xyz + 0.5);\n  __GET_WRAPAROUND__;\n  highp float index = round(xyz.x + texDim.x * (xyz.y + texDim.y * xyz.z));\n  __GET_TEXTURE_CHANNEL__;\n  highp float w = round(texSize.x);\n  vec2 st = vec2(integerMod(index, w), float(int(index) / int(w))) + 0.5;\n  __GET_TEXTURE_INDEX__;\n  highp vec4 texel = texture2D(tex, st / texSize);\n  __GET_RESULT__;\n}\n\nhighp float get(highp sampler2D tex, highp vec2 texSize, highp vec3 texDim, highp float y, highp float x) {\n  return get(tex, texSize, texDim, 0.0, y, x);\n}\n\nhighp float get(highp sampler2D tex, highp vec2 texSize, highp vec3 texDim, highp float x) {\n  return get(tex, texSize, texDim, 0.0, 0.0, x);\n}\n\nhighp vec4 actualColor;\nvoid color(float r, float g, float b, float a) {\n  actualColor = vec4(r,g,b,a);\n}\n\nvoid color(float r, float g, float b) {\n  color(r,g,b,1.0);\n}\n\n__MAIN_PARAMS__;\n__MAIN_CONSTANTS__;\n__KERNEL__;\n\nvoid main(void) {\n  index = floor(vTexCoord.s * float(uTexSize.x)) + floor(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;\n  __MAIN_RESULT__;\n}" }, {}], 17: [function (t, e, n) { e.exports = "precision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\nattribute highp vec2 aPos;\nattribute highp vec2 aTexCoord;\n\nvarying highp vec2 vTexCoord;\nuniform vec2 ratio;\n\nvoid main(void) {\n  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);\n  vTexCoord = aTexCoord;\n}" }, {}], 18: [function (t, e, n) { var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); var r = t("./kernel"), s = t("../../core/utils"); e.exports = function (t) { function e() { return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, e), function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)) } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, r), i(e, [{ key: "validateOptions", value: function () { this.texSize = s.dimToTexSize({ floatTextures: this.floatTextures, floatOutput: this.floatOutput }, this.output, !0) } }]), e }() }, { "../../core/utils": 25, "./kernel": 14 }], 19: [function (t, e, n) { var i = t("./utils"); e.exports = function (t, e) { var n = e.toString(); return new Function("return function " + t + " (" + i.getParamNamesFromString(n).join(", ") + ") {" + i.getFunctionBodyFromString(n) + "}")() } }, { "./utils": 25 }], 20: [function (t, e, n) { var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); t("./utils-core"); e.exports = function () { function t() { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t) } return i(t, null, [{ key: "validateKernelObj", value: function (t) { if (null === t) throw "KernelObj being validated is NULL"; if ("string" == typeof t) { try { t = JSON.parse(t) } catch (t) { throw console.error(t), "Failed to convert KernelObj from JSON string" } if (null === t) throw "Invalid (NULL) KernelObj JSON string representation" } if (!0 !== t.isKernelObj) throw "Failed missing isKernelObj flag check"; return t } }, { key: "loadKernelObj", value: function (t, e) { t = validateKernelObj(t) } }]), t }() }, { "./utils-core": 24 }], 21: [function (t, e, n) { var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); var r = t("./utils"), s = t("../backend/web-gl/runner"), a = t("../backend/cpu/runner"), o = t("../backend/web-gl/validator-kernel"), u = t("./gpu-core"), h = function (t) { function e(t) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, e); var n = function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t)); t = t || {}, n._canvas = t.canvas || null, n._webGl = t.webGl || null; var i = t.mode, u = void 0; if (r.isWebGlSupported()) u = i || "gpu"; else { if (i && "cpu" !== i) throw new Error('A requested mode of "' + i + '" and is not supported'); console.warn("Warning: gpu not supported, falling back to cpu support"), u = "cpu" } n.kernels = []; var h = { canvas: n._canvas, webGl: n._webGl }; switch (u) { case "cpu": n._runner = new a(h); break; case "webgl": case "gpu": n._runner = new s(h); break; case "webgl-validator": n._runner = new s(h), n._runner.Kernel = o; break; default: throw new Error('"' + i + '" mode is not defined') }return n } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, u), i(e, [{ key: "createKernel", value: function (t, e) { if (void 0 === t) throw "Missing fn parameter"; if (!r.isFunction(t) && "string" != typeof t) throw "fn parameter not a function"; var n = this._runner.buildKernel(t, e || {}); return this._canvas || (this._canvas = n.getCanvas()), this._runner.canvas || (this._runner.canvas = n.getCanvas()), this.kernels.push(n), n } }, { key: "createKernelMap", value: function () { var t = void 0, e = void 0; "function" == typeof arguments[arguments.length - 2] ? (t = arguments[arguments.length - 2], e = arguments[arguments.length - 1]) : t = arguments[arguments.length - 1], r.isWebGlDrawBuffersSupported() || (this._runner = new a(e)); var n = this.createKernel(t, e); if (Array.isArray(arguments[0])) for (var i = arguments[0], s = 0; s < i.length; s++)n.addSubKernel(i[s]); else { var o = arguments[0]; for (var u in o) o.hasOwnProperty(u) && n.addSubKernelProperty(u, o[u]) } return n } }, { key: "combineKernels", value: function () { var t = arguments[arguments.length - 2], e = arguments[arguments.length - 1]; if ("cpu" === this.getMode()) return e; for (var n = arguments[0].getCanvas(), i = arguments[0].getWebGl(), s = 0; s < arguments.length - 1; s++)arguments[s].setCanvas(n).setWebGl(i).setOutputToTexture(!0); return function () { e.apply(null, arguments); var n = t.texSize, i = t.getWebGl(), s = t.threadDim, a = void 0; if (t.floatOutput) a = new Float32Array(n[0] * n[1] * 4), i.readPixels(0, 0, n[0], n[1], i.RGBA, i.FLOAT, a); else { var o = new Uint8Array(n[0] * n[1] * 4); i.readPixels(0, 0, n[0], n[1], i.RGBA, i.UNSIGNED_BYTE, o), a = new Float32Array(o.buffer) } return a = a.subarray(0, s[0] * s[1] * s[2]), 1 === t.output.length ? a : 2 === t.output.length ? r.splitArray(a, t.output[0]) : 3 === t.output.length ? r.splitArray(a, t.output[0] * t.output[1]).map(function (e) { return r.splitArray(e, t.output[0]) }) : void 0 } } }, { key: "addFunction", value: function (t, e, n) { return this._runner.functionBuilder.addFunction(null, t, e, n), this } }, { key: "addNativeFunction", value: function (t, e) { return this._runner.functionBuilder.addNativeFunction(t, e), this } }, { key: "getMode", value: function () { return this._runner.getMode() } }, { key: "isWebGlSupported", value: function () { return r.isWebGlSupported() } }, { key: "getCanvas", value: function () { return this._canvas } }, { key: "getWebGl", value: function () { return this._webGl } }]), e }(); Object.assign(h, u), e.exports = h }, { "../backend/cpu/runner": 5, "../backend/web-gl/runner": 15, "../backend/web-gl/validator-kernel": 18, "./gpu-core": 20, "./utils": 25 }], 22: [function (t, e, n) { e.exports = function t(e, n) { if (function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.value = e, Array.isArray(n)) { this.size = []; for (var i = 0; i < n.length; i++)this.size[i] = n[i]; for (; this.size.length < 3;)this.size.push(1) } else n.z ? this.size = [n.x, n.y, n.z] : n.y ? this.size = [n.x, n.y, 1] : this.size = [n.x, 1, 1] } }, {}], 23: [function (t, e, n) { var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); e.exports = function () { function t(e, n, i, r) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.texture = e, this.size = n, this.output = i, this.webGl = r, this.kernel = null } return i(t, [{ key: "toArray", value: function (t) { if (!t) throw new Error("You need to pass the GPU object for toArray to work."); return this.kernel ? this.kernel(this) : (this.kernel = t.createKernel(function (t) { return t[this.thread.z][this.thread.y][this.thread.x] }).setOutput(this.output), this.kernel(this)) } }, { key: "delete", value: function () { return this.webGl.deleteTexture(this.texture) } }]), t }() }, {}], 24: [function (t, e, n) { var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); var r = function () { function t() { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t) } return i(t, null, [{ key: "isCanvas", value: function (t) { return null !== t && t.nodeName && t.getContext && "CANVAS" === t.nodeName.toUpperCase() } }, { key: "isCanvasSupported", value: function () { return s } }, { key: "initCanvas", value: function () { if (!s) return null; var t = document.createElement("canvas"); return t.width = 2, t.height = 2, t } }, { key: "isWebGl", value: function (t) { return t && "function" == typeof t.getExtension } }, { key: "isWebGlSupported", value: function () { return o } }, { key: "isWebGlDrawBuffersSupported", value: function () { return u } }, { key: "initWebGlDefaultOptions", value: function () { return { alpha: !1, depth: !1, antialias: !1 } } }, { key: "initWebGl", value: function (e) { if ((void 0 !== s || null === e) && !s) return null; if (!t.isCanvas(e)) throw new Error("Invalid canvas object - " + e); var n = e.getContext("experimental-webgl", t.initWebGlDefaultOptions()) || e.getContext("webgl", t.initWebGlDefaultOptions()); return n && (n.OES_texture_float = n.getExtension("OES_texture_float"), n.OES_texture_float_linear = n.getExtension("OES_texture_float_linear"), n.OES_element_index_uint = n.getExtension("OES_element_index_uint")), n } }]), t }(), s = "undefined" != typeof document && r.isCanvas(document.createElement("canvas")), a = r.initWebGl(r.initCanvas()), o = r.isWebGl(a), u = o && Boolean(a.getExtension("WEBGL_draw_buffers")); o ? (r.OES_texture_float = a.OES_texture_float, r.OES_texture_float_linear = a.OES_texture_float_linear, r.OES_element_index_uint = a.OES_element_index_uint) : (r.OES_texture_float = !1, r.OES_texture_float_linear = !1, r.OES_element_index_uint = !1), e.exports = r }, {}], 25: [function (t, e, n) { var i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, r = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); var s = t("./utils-core"), a = t("./input"), o = t("./texture"), u = /function ([^(]*)/, h = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm, l = /([^\s,]+)/g, p = function () { var t = new ArrayBuffer(4), e = new Uint32Array(t), n = new Uint8Array(t); if (e[0] = 3735928559, 239 === n[0]) return "LE"; if (222 === n[0]) return "BE"; throw new Error("unknown endianness") }(), c = null, f = function () { try { return new Function("let i = 1; const j = 1;")(), !0 } catch (t) { return !1 } }(), d = function (e) { function n() { return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, n), function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, (n.__proto__ || Object.getPrototypeOf(n)).apply(this, arguments)) } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(n, s), r(n, null, [{ key: "systemEndianness", value: function () { return p } }, { key: "isFunction", value: function (t) { return "function" == typeof t } }, { key: "isFunctionString", value: function (t) { return null !== t && "function" === t.toString().slice(0, "function".length).toLowerCase() } }, { key: "getFunctionNameFromString", value: function (t) { return u.exec(t)[1] } }, { key: "getFunctionBodyFromString", value: function (t) { return t.substring(t.indexOf("{") + 1, t.lastIndexOf("}")) } }, { key: "getParamNamesFromString", value: function (t) { var e = t.toString().replace(h, ""), n = e.slice(e.indexOf("(") + 1, e.indexOf(")")).match(l); return null === n && (n = []), n } }, { key: "clone", value: function (t) { if (null === t || "object" !== (void 0 === t ? "undefined" : i(t)) || t.hasOwnProperty("isActiveClone")) return t; var e = t.constructor(); for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (t.isActiveClone = null, e[r] = n.clone(t[r]), delete t.isActiveClone); return e } }, { key: "newPromise", value: function (t) { var e = Promise || small_promise; if (null === e) throw TypeError("Browser is missing Promise implementation. Consider adding small_promise.js polyfill"); return new e(t) } }, { key: "functionBinder", value: function (t, e) { return t.bind ? t.bind(e) : function () { var n = 1 === arguments.length ? [arguments[0]] : Array.apply(null, arguments); return t.apply(e, n) } } }, { key: "isArray", value: function (t) { return !isNaN(t.length) } }, { key: "getArgumentType", value: function (t) { return n.isArray(t) ? "Array" : "number" == typeof t ? "Number" : t instanceof o ? "Texture" : t instanceof a ? "Input" : "Unknown" } }, { key: "isFloatReadPixelsSupported", value: function () { if (null !== c) return c; var e = new (t("../index"))({ mode: "webgl-validator" }).createKernel(function () { return 1 }, { output: [2], floatTextures: !0, floatOutput: !0, floatOutputForce: !0 })(); return c = 1 === e[0] } }, { key: "isMixedIdentifiersSupported", value: function () { return f } }, { key: "dimToTexSize", value: function (t, e, n) { for (var i = e[0], r = 1; r < e.length; r++)i *= e[r]; !t.floatTextures || n && !t.floatOutput || (i = Math.ceil(i / 4)); var s = Math.ceil(Math.sqrt(i)); return [s, s] } }, { key: "getDimensions", value: function (t, e) { var i = void 0; if (n.isArray(t)) { for (var r = [], s = t; n.isArray(s);)r.push(s.length), s = s[0]; i = r.reverse() } else if (t instanceof o) i = t.output; else { if (!(t instanceof a)) throw "Unknown dimensions of " + t; i = t.size } if (e) for (i = n.clone(i); i.length < 3;)i.push(1); return i } }, { key: "pad", value: function (t, e) { function n(t) { return Array.apply(null, new Array(t)).map(Number.prototype.valueOf, 0) } for (var i = t.length + 2 * e, r = t.map(function (t) { return [].concat(n(e), t, n(e)) }), s = 0; s < e; s++)r = [].concat([n(i)], r, [n(i)]); return r } }, { key: "flatten2dArrayTo", value: function (t, e) { for (var n = 0, i = 0; i < t.length; i++)e.set(t[i], n), n += t[i].length } }, { key: "flatten3dArrayTo", value: function (t, e) { for (var n = 0, i = 0; i < t.length; i++)for (var r = 0; r < t[i].length; r++)e.set(t[i][r], n), n += t[i][r].length } }, { key: "flattenTo", value: function (t, e) { n.isArray(t[0]) ? n.isArray(t[0][0]) ? n.flatten3dArrayTo(t, e) : n.flatten2dArrayTo(t, e) : e.set(t) } }, { key: "splitArray", value: function (t, e) { for (var n = [], i = 0; i < t.length; i += e)n.push(Array.prototype.slice.call(t, i, i + e)); return n } }, { key: "getAstString", value: function (t, e) { var n = Array.isArray(t) ? t : t.split(/\r?\n/g), i = e.loc.start, r = e.loc.end, s = []; s.push(n[i.line - 1].slice(i.column)); for (var a = i.line; a < r.line - 1; a++)s.push(n[a]); return s.push(n[r.line - 1].slice(0, r.column)), s.join("\n") } }, { key: "allPropertiesOf", value: function (t) { var e = []; do { e.push.apply(e, Object.getOwnPropertyNames(t)) } while (t = Object.getPrototypeOf(t)); return e } }]), n }(); Object.assign(d, s), e.exports = d }, { "../index": 26, "./input": 22, "./texture": 23, "./utils-core": 24 }], 26: [function (t, e, n) { var i = t("./core/gpu"), r = t("./core/alias"), s = t("./core/utils"), a = t("./core/input"), o = t("./core/texture"), u = t("./backend/cpu/function-builder"), h = t("./backend/cpu/function-node"), l = t("./backend/cpu/kernel"), p = t("./backend/cpu/runner"), c = t("./backend/web-gl/function-builder"), f = t("./backend/web-gl/function-node"), d = t("./backend/web-gl/kernel"), m = t("./backend/web-gl/runner"); i.alias = r, i.utils = s, i.Texture = o, i.Input = a, i.input = function (t, e) { return new a(t, e) }, i.CPUFunctionBuilder = u, i.CPUFunctionNode = h, i.CPUKernel = l, i.CPURunner = p, i.WebGLFunctionBuilder = c, i.WebGLFunctionNode = f, i.WebGLKernel = d, i.WebGLRunner = m, void 0 !== e && (e.exports = i), "undefined" != typeof window && (window.GPU = i) }, { "./backend/cpu/function-builder": 1, "./backend/cpu/function-node": 2, "./backend/cpu/kernel": 4, "./backend/cpu/runner": 5, "./backend/web-gl/function-builder": 11, "./backend/web-gl/function-node": 12, "./backend/web-gl/kernel": 14, "./backend/web-gl/runner": 15, "./core/alias": 19, "./core/gpu": 21, "./core/input": 22, "./core/texture": 23, "./core/utils": 25 }], 27: [function (t, e, n) { var i, r; i = this, r = function (t) { var e = { 3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile", 5: "class enum extends super const export import", 6: "enum", strict: "implements interface let package private protected public static yield", strictBind: "eval arguments" }, n = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", i = { 5: n, 6: n + " const class extends export import super" }, r = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠ-ࢴࢶ-ࢽऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿕ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞮꞰ-ꞷꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭥꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", s = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣔ-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఃా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഁ-ഃാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ູົຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭ᳲ-᳴᳸᳹᷀-᷵᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱꤀-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿", a = new RegExp("[" + r + "]"), o = new RegExp("[" + r + s + "]"); r = s = null; var u = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 449, 56, 264, 8, 2, 36, 18, 0, 50, 29, 881, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 65, 0, 32, 6124, 20, 754, 9486, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 10591, 541], h = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 87, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 838, 7, 2, 7, 17, 9, 57, 21, 2, 13, 19882, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239]; function l(t, e) { for (var n = 65536, i = 0; i < e.length; i += 2) { if ((n += e[i]) > t) return !1; if ((n += e[i + 1]) >= t) return !0 } } function p(t, e) { return t < 65 ? 36 === t : t < 91 || (t < 97 ? 95 === t : t < 123 || (t <= 65535 ? t >= 170 && a.test(String.fromCharCode(t)) : !1 !== e && l(t, u))) } function c(t, e) { return t < 48 ? 36 === t : t < 58 || !(t < 65) && (t < 91 || (t < 97 ? 95 === t : t < 123 || (t <= 65535 ? t >= 170 && o.test(String.fromCharCode(t)) : !1 !== e && (l(t, u) || l(t, h))))) } var f = function (t, e) { void 0 === e && (e = {}), this.label = t, this.keyword = e.keyword, this.beforeExpr = !!e.beforeExpr, this.startsExpr = !!e.startsExpr, this.isLoop = !!e.isLoop, this.isAssign = !!e.isAssign, this.prefix = !!e.prefix, this.postfix = !!e.postfix, this.binop = e.binop || null, this.updateContext = null }; function d(t, e) { return new f(t, { beforeExpr: !0, binop: e }) } var m = { beforeExpr: !0 }, g = { startsExpr: !0 }, y = {}; function v(t, e) { return void 0 === e && (e = {}), e.keyword = t, y[t] = new f(t, e) } var b = { num: new f("num", g), regexp: new f("regexp", g), string: new f("string", g), name: new f("name", g), eof: new f("eof"), bracketL: new f("[", { beforeExpr: !0, startsExpr: !0 }), bracketR: new f("]"), braceL: new f("{", { beforeExpr: !0, startsExpr: !0 }), braceR: new f("}"), parenL: new f("(", { beforeExpr: !0, startsExpr: !0 }), parenR: new f(")"), comma: new f(",", m), semi: new f(";", m), colon: new f(":", m), dot: new f("."), question: new f("?", m), arrow: new f("=>", m), template: new f("template"), invalidTemplate: new f("invalidTemplate"), ellipsis: new f("...", m), backQuote: new f("`", g), dollarBraceL: new f("${", { beforeExpr: !0, startsExpr: !0 }), eq: new f("=", { beforeExpr: !0, isAssign: !0 }), assign: new f("_=", { beforeExpr: !0, isAssign: !0 }), incDec: new f("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }), prefix: new f("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), logicalOR: d("||", 1), logicalAND: d("&&", 2), bitwiseOR: d("|", 3), bitwiseXOR: d("^", 4), bitwiseAND: d("&", 5), equality: d("==/!=/===/!==", 6), relational: d("</>/<=/>=", 7), bitShift: d("<</>>/>>>", 8), plusMin: new f("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }), modulo: d("%", 10), star: d("*", 10), slash: d("/", 10), starstar: new f("**", { beforeExpr: !0 }), _break: v("break"), _case: v("case", m), _catch: v("catch"), _continue: v("continue"), _debugger: v("debugger"), _default: v("default", m), _do: v("do", { isLoop: !0, beforeExpr: !0 }), _else: v("else", m), _finally: v("finally"), _for: v("for", { isLoop: !0 }), _function: v("function", g), _if: v("if"), _return: v("return", m), _switch: v("switch"), _throw: v("throw", m), _try: v("try"), _var: v("var"), _const: v("const"), _while: v("while", { isLoop: !0 }), _with: v("with"), _new: v("new", { beforeExpr: !0, startsExpr: !0 }), _this: v("this", g), _super: v("super", g), _class: v("class", g), _extends: v("extends", m), _export: v("export"), _import: v("import"), _null: v("null", g), _true: v("true", g), _false: v("false", g), _in: v("in", { beforeExpr: !0, binop: 7 }), _instanceof: v("instanceof", { beforeExpr: !0, binop: 7 }), _typeof: v("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _void: v("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _delete: v("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 }) }, x = /\r\n?|\n|\u2028|\u2029/, k = new RegExp(x.source, "g"); function E(t) { return 10 === t || 13 === t || 8232 === t || 8233 === t } var S = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/, _ = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, w = Object.prototype, T = w.hasOwnProperty, A = w.toString; function O(t, e) { return T.call(t, e) } var N = Array.isArray || function (t) { return "[object Array]" === A.call(t) }, P = function (t, e) { this.line = t, this.column = e }; P.prototype.offset = function (t) { return new P(this.line, this.column + t) }; var C = function (t, e, n) { this.start = e, this.end = n, null !== t.sourceFile && (this.source = t.sourceFile) }; function F(t, e) { for (var n = 1, i = 0; ;) { k.lastIndex = i; var r = k.exec(t); if (!(r && r.index < e)) return new P(n, e - i); ++n, i = r.index + r[0].length } } var R = { ecmaVersion: 7, sourceType: "script", onInsertedSemicolon: null, onTrailingComma: null, allowReserved: null, allowReturnOutsideFunction: !1, allowImportExportEverywhere: !1, allowHashBang: !1, locations: !1, onToken: null, onComment: null, ranges: !1, program: null, sourceFile: null, directSourceFile: null, preserveParens: !1, plugins: {} }; function L(t) { var e = {}; for (var n in R) e[n] = t && O(t, n) ? t[n] : R[n]; if (e.ecmaVersion >= 2015 && (e.ecmaVersion -= 2009), null == e.allowReserved && (e.allowReserved = e.ecmaVersion < 5), N(e.onToken)) { var i = e.onToken; e.onToken = function (t) { return i.push(t) } } return N(e.onComment) && (e.onComment = function (t, e) { return function (n, i, r, s, a, o) { var u = { type: n ? "Block" : "Line", value: i, start: r, end: s }; t.locations && (u.loc = new C(this, a, o)), t.ranges && (u.range = [r, s]), e.push(u) } }(e, e.onComment)), e } var I = {}; function D(t) { return new RegExp("^(?:" + t.replace(/ /g, "|") + ")$") } var G = function (t, n, r) { this.options = t = L(t), this.sourceFile = t.sourceFile, this.keywords = D(i[t.ecmaVersion >= 6 ? 6 : 5]); var s = ""; if (!t.allowReserved) { for (var a = t.ecmaVersion; !(s = e[a]); a--); "module" == t.sourceType && (s += " await") } this.reservedWords = D(s); var o = (s ? s + " " : "") + e.strict; this.reservedWordsStrict = D(o), this.reservedWordsStrictBind = D(o + " " + e.strictBind), this.input = String(n), this.containsEsc = !1, this.loadPlugins(t.plugins), r ? (this.pos = r, this.lineStart = this.input.lastIndexOf("\n", r - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(x).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = b.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = "module" === t.sourceType, this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.inFunction = this.inGenerator = this.inAsync = !1, this.yieldPos = this.awaitPos = 0, this.labels = [], 0 === this.pos && t.allowHashBang && "#!" === this.input.slice(0, 2) && this.skipLineComment(2), this.scopeStack = [], this.enterFunctionScope() }; G.prototype.isKeyword = function (t) { return this.keywords.test(t) }, G.prototype.isReservedWord = function (t) { return this.reservedWords.test(t) }, G.prototype.extend = function (t, e) { this[t] = e(this[t]) }, G.prototype.loadPlugins = function (t) { for (var e in t) { var n = I[e]; if (!n) throw new Error("Plugin '" + e + "' not found"); n(this, t[e]) } }, G.prototype.parse = function () { var t = this.options.program || this.startNode(); return this.nextToken(), this.parseTopLevel(t) }; var M = G.prototype, U = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)"|;)/; function j() { this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = -1 } M.strictDirective = function (t) { for (; ;) { _.lastIndex = t, t += _.exec(this.input)[0].length; var e = U.exec(this.input.slice(t)); if (!e) return !1; if ("use strict" == (e[1] || e[2])) return !0; t += e[0].length } }, M.eat = function (t) { return this.type === t && (this.next(), !0) }, M.isContextual = function (t) { return this.type === b.name && this.value === t }, M.eatContextual = function (t) { return this.value === t && this.eat(b.name) }, M.expectContextual = function (t) { this.eatContextual(t) || this.unexpected() }, M.canInsertSemicolon = function () { return this.type === b.eof || this.type === b.braceR || x.test(this.input.slice(this.lastTokEnd, this.start)) }, M.insertSemicolon = function () { if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0 }, M.semicolon = function () { this.eat(b.semi) || this.insertSemicolon() || this.unexpected() }, M.afterTrailingComma = function (t, e) { if (this.type == t) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), e || this.next(), !0 }, M.expect = function (t) { this.eat(t) || this.unexpected() }, M.unexpected = function (t) { this.raise(null != t ? t : this.start, "Unexpected token") }, M.checkPatternErrors = function (t, e) { if (t) { t.trailingComma > -1 && this.raiseRecoverable(t.trailingComma, "Comma is not permitted after the rest element"); var n = e ? t.parenthesizedAssign : t.parenthesizedBind; n > -1 && this.raiseRecoverable(n, "Parenthesized pattern") } }, M.checkExpressionErrors = function (t, e) { var n = t ? t.shorthandAssign : -1; if (!e) return n >= 0; n > -1 && this.raise(n, "Shorthand property assignments are valid only in destructuring patterns") }, M.checkYieldAwaitInDefaultParams = function () { this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value") }, M.isSimpleAssignTarget = function (t) { return "ParenthesizedExpression" === t.type ? this.isSimpleAssignTarget(t.expression) : "Identifier" === t.type || "MemberExpression" === t.type }; var B = G.prototype; B.parseTopLevel = function (t) { var e = {}; for (t.body || (t.body = []); this.type !== b.eof;) { var n = this.parseStatement(!0, !0, e); t.body.push(n) } return this.adaptDirectivePrologue(t.body), this.next(), this.options.ecmaVersion >= 6 && (t.sourceType = this.options.sourceType), this.finishNode(t, "Program") }; var K = { kind: "loop" }, V = { kind: "switch" }; B.isLet = function () { if (this.type !== b.name || this.options.ecmaVersion < 6 || "let" != this.value) return !1; _.lastIndex = this.pos; var t = _.exec(this.input), e = this.pos + t[0].length, n = this.input.charCodeAt(e); if (91 === n || 123 == n) return !0; if (p(n, !0)) { for (var i = e + 1; c(this.input.charCodeAt(i), !0);)++i; var r = this.input.slice(e, i); if (!this.isKeyword(r)) return !0 } return !1 }, B.isAsyncFunction = function () { if (this.type !== b.name || this.options.ecmaVersion < 8 || "async" != this.value) return !1; _.lastIndex = this.pos; var t = _.exec(this.input), e = this.pos + t[0].length; return !(x.test(this.input.slice(this.pos, e)) || "function" !== this.input.slice(e, e + 8) || e + 8 != this.input.length && c(this.input.charAt(e + 8))) }, B.parseStatement = function (t, e, n) { var i, r = this.type, s = this.startNode(); switch (this.isLet() && (r = b._var, i = "let"), r) { case b._break: case b._continue: return this.parseBreakContinueStatement(s, r.keyword); case b._debugger: return this.parseDebuggerStatement(s); case b._do: return this.parseDoStatement(s); case b._for: return this.parseForStatement(s); case b._function: return !t && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(s, !1); case b._class: return t || this.unexpected(), this.parseClass(s, !0); case b._if: return this.parseIfStatement(s); case b._return: return this.parseReturnStatement(s); case b._switch: return this.parseSwitchStatement(s); case b._throw: return this.parseThrowStatement(s); case b._try: return this.parseTryStatement(s); case b._const: case b._var: return i = i || this.value, t || "var" == i || this.unexpected(), this.parseVarStatement(s, i); case b._while: return this.parseWhileStatement(s); case b._with: return this.parseWithStatement(s); case b.braceL: return this.parseBlock(); case b.semi: return this.parseEmptyStatement(s); case b._export: case b._import: return this.options.allowImportExportEverywhere || (e || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), r === b._import ? this.parseImport(s) : this.parseExport(s, n); default: if (this.isAsyncFunction() && t) return this.next(), this.parseFunctionStatement(s, !0); var a = this.value, o = this.parseExpression(); return r === b.name && "Identifier" === o.type && this.eat(b.colon) ? this.parseLabeledStatement(s, a, o) : this.parseExpressionStatement(s, o) } }, B.parseBreakContinueStatement = function (t, e) { var n = "break" == e; this.next(), this.eat(b.semi) || this.insertSemicolon() ? t.label = null : this.type !== b.name ? this.unexpected() : (t.label = this.parseIdent(), this.semicolon()); for (var i = 0; i < this.labels.length; ++i) { var r = this.labels[i]; if (null == t.label || r.name === t.label.name) { if (null != r.kind && (n || "loop" === r.kind)) break; if (t.label && n) break } } return i === this.labels.length && this.raise(t.start, "Unsyntactic " + e), this.finishNode(t, n ? "BreakStatement" : "ContinueStatement") }, B.parseDebuggerStatement = function (t) { return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement") }, B.parseDoStatement = function (t) { return this.next(), this.labels.push(K), t.body = this.parseStatement(!1), this.labels.pop(), this.expect(b._while), t.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(b.semi) : this.semicolon(), this.finishNode(t, "DoWhileStatement") }, B.parseForStatement = function (t) { if (this.next(), this.labels.push(K), this.enterLexicalScope(), this.expect(b.parenL), this.type === b.semi) return this.parseFor(t, null); var e = this.isLet(); if (this.type === b._var || this.type === b._const || e) { var n = this.startNode(), i = e ? "let" : this.value; return this.next(), this.parseVar(n, !0, i), this.finishNode(n, "VariableDeclaration"), !(this.type === b._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) || 1 !== n.declarations.length || "var" !== i && n.declarations[0].init ? this.parseFor(t, n) : this.parseForIn(t, n) } var r = new j, s = this.parseExpression(!0, r); return this.type === b._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? (this.toAssignable(s), this.checkLVal(s), this.checkPatternErrors(r, !0), this.parseForIn(t, s)) : (this.checkExpressionErrors(r, !0), this.parseFor(t, s)) }, B.parseFunctionStatement = function (t, e) { return this.next(), this.parseFunction(t, !0, !1, e) }, B.isFunction = function () { return this.type === b._function || this.isAsyncFunction() }, B.parseIfStatement = function (t) { return this.next(), t.test = this.parseParenExpression(), t.consequent = this.parseStatement(!this.strict && this.isFunction()), t.alternate = this.eat(b._else) ? this.parseStatement(!this.strict && this.isFunction()) : null, this.finishNode(t, "IfStatement") }, B.parseReturnStatement = function (t) { return this.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.start, "'return' outside of function"), this.next(), this.eat(b.semi) || this.insertSemicolon() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement") }, B.parseSwitchStatement = function (t) { var e; this.next(), t.discriminant = this.parseParenExpression(), t.cases = [], this.expect(b.braceL), this.labels.push(V), this.enterLexicalScope(); for (var n = !1; this.type != b.braceR;)if (this.type === b._case || this.type === b._default) { var i = this.type === b._case; e && this.finishNode(e, "SwitchCase"), t.cases.push(e = this.startNode()), e.consequent = [], this.next(), i ? e.test = this.parseExpression() : (n && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), n = !0, e.test = null), this.expect(b.colon) } else e || this.unexpected(), e.consequent.push(this.parseStatement(!0)); return this.exitLexicalScope(), e && this.finishNode(e, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(t, "SwitchStatement") }, B.parseThrowStatement = function (t) { return this.next(), x.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement") }; var z = []; B.parseTryStatement = function (t) { if (this.next(), t.block = this.parseBlock(), t.handler = null, this.type === b._catch) { var e = this.startNode(); this.next(), this.expect(b.parenL), e.param = this.parseBindingAtom(), this.enterLexicalScope(), this.checkLVal(e.param, "let"), this.expect(b.parenR), e.body = this.parseBlock(!1), this.exitLexicalScope(), t.handler = this.finishNode(e, "CatchClause") } return t.finalizer = this.eat(b._finally) ? this.parseBlock() : null, t.handler || t.finalizer || this.raise(t.start, "Missing catch or finally clause"), this.finishNode(t, "TryStatement") }, B.parseVarStatement = function (t, e) { return this.next(), this.parseVar(t, !1, e), this.semicolon(), this.finishNode(t, "VariableDeclaration") }, B.parseWhileStatement = function (t) { return this.next(), t.test = this.parseParenExpression(), this.labels.push(K), t.body = this.parseStatement(!1), this.labels.pop(), this.finishNode(t, "WhileStatement") }, B.parseWithStatement = function (t) { return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), t.object = this.parseParenExpression(), t.body = this.parseStatement(!1), this.finishNode(t, "WithStatement") }, B.parseEmptyStatement = function (t) { return this.next(), this.finishNode(t, "EmptyStatement") }, B.parseLabeledStatement = function (t, e, n) { for (var i = 0, r = this.labels; i < r.length; i += 1) { r[i].name === e && this.raise(n.start, "Label '" + e + "' is already declared") } for (var s = this.type.isLoop ? "loop" : this.type === b._switch ? "switch" : null, a = this.labels.length - 1; a >= 0; a--) { var o = this.labels[a]; if (o.statementStart != t.start) break; o.statementStart = this.start, o.kind = s } return this.labels.push({ name: e, kind: s, statementStart: this.start }), t.body = this.parseStatement(!0), ("ClassDeclaration" == t.body.type || "VariableDeclaration" == t.body.type && "var" != t.body.kind || "FunctionDeclaration" == t.body.type && (this.strict || t.body.generator)) && this.raiseRecoverable(t.body.start, "Invalid labeled declaration"), this.labels.pop(), t.label = n, this.finishNode(t, "LabeledStatement") }, B.parseExpressionStatement = function (t, e) { return t.expression = e, this.semicolon(), this.finishNode(t, "ExpressionStatement") }, B.parseBlock = function (t) { void 0 === t && (t = !0); var e = this.startNode(); for (e.body = [], this.expect(b.braceL), t && this.enterLexicalScope(); !this.eat(b.braceR);) { var n = this.parseStatement(!0); e.body.push(n) } return t && this.exitLexicalScope(), this.finishNode(e, "BlockStatement") }, B.parseFor = function (t, e) { return t.init = e, this.expect(b.semi), t.test = this.type === b.semi ? null : this.parseExpression(), this.expect(b.semi), t.update = this.type === b.parenR ? null : this.parseExpression(), this.expect(b.parenR), this.exitLexicalScope(), t.body = this.parseStatement(!1), this.labels.pop(), this.finishNode(t, "ForStatement") }, B.parseForIn = function (t, e) { var n = this.type === b._in ? "ForInStatement" : "ForOfStatement"; return this.next(), t.left = e, t.right = this.parseExpression(), this.expect(b.parenR), this.exitLexicalScope(), t.body = this.parseStatement(!1), this.labels.pop(), this.finishNode(t, n) }, B.parseVar = function (t, e, n) { for (t.declarations = [], t.kind = n; ;) { var i = this.startNode(); if (this.parseVarId(i, n), this.eat(b.eq) ? i.init = this.parseMaybeAssign(e) : "const" !== n || this.type === b._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? "Identifier" == i.id.type || e && (this.type === b._in || this.isContextual("of")) ? i.init = null : this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : this.unexpected(), t.declarations.push(this.finishNode(i, "VariableDeclarator")), !this.eat(b.comma)) break } return t }, B.parseVarId = function (t, e) { t.id = this.parseBindingAtom(e), this.checkLVal(t.id, e, !1) }, B.parseFunction = function (t, e, n, i) { this.initFunction(t), this.options.ecmaVersion >= 6 && !i && (t.generator = this.eat(b.star)), this.options.ecmaVersion >= 8 && (t.async = !!i), e && (t.id = "nullableID" === e && this.type != b.name ? null : this.parseIdent(), t.id && this.checkLVal(t.id, "var")); var r = this.inGenerator, s = this.inAsync, a = this.yieldPos, o = this.awaitPos, u = this.inFunction; return this.inGenerator = t.generator, this.inAsync = t.async, this.yieldPos = 0, this.awaitPos = 0, this.inFunction = !0, this.enterFunctionScope(), e || (t.id = this.type == b.name ? this.parseIdent() : null), this.parseFunctionParams(t), this.parseFunctionBody(t, n), this.inGenerator = r, this.inAsync = s, this.yieldPos = a, this.awaitPos = o, this.inFunction = u, this.finishNode(t, e ? "FunctionDeclaration" : "FunctionExpression") }, B.parseFunctionParams = function (t) { this.expect(b.parenL), t.params = this.parseBindingList(b.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams() }, B.parseClass = function (t, e) { this.next(), this.parseClassId(t, e), this.parseClassSuper(t); var n = this.startNode(), i = !1; for (n.body = [], this.expect(b.braceL); !this.eat(b.braceR);)if (!this.eat(b.semi)) { var r = this.startNode(), s = this.eat(b.star), a = !1, o = this.type === b.name && "static" === this.value; this.parsePropertyName(r), r.static = o && this.type !== b.parenL, r.static && (s && this.unexpected(), s = this.eat(b.star), this.parsePropertyName(r)), this.options.ecmaVersion >= 8 && !s && !r.computed && "Identifier" === r.key.type && "async" === r.key.name && this.type !== b.parenL && !this.canInsertSemicolon() && (a = !0, this.parsePropertyName(r)), r.kind = "method"; var u = !1; if (!r.computed) { var h = r.key; s || a || "Identifier" !== h.type || this.type === b.parenL || "get" !== h.name && "set" !== h.name || (u = !0, r.kind = h.name, h = this.parsePropertyName(r)), !r.static && ("Identifier" === h.type && "constructor" === h.name || "Literal" === h.type && "constructor" === h.value) && (i && this.raise(h.start, "Duplicate constructor in the same class"), u && this.raise(h.start, "Constructor can't have get/set modifier"), s && this.raise(h.start, "Constructor can't be a generator"), a && this.raise(h.start, "Constructor can't be an async method"), r.kind = "constructor", i = !0) } if (this.parseClassMethod(n, r, s, a), u) { var l = "get" === r.kind ? 0 : 1; if (r.value.params.length !== l) { var p = r.value.start; "get" === r.kind ? this.raiseRecoverable(p, "getter should have no params") : this.raiseRecoverable(p, "setter should have exactly one param") } else "set" === r.kind && "RestElement" === r.value.params[0].type && this.raiseRecoverable(r.value.params[0].start, "Setter cannot use rest params") } } return t.body = this.finishNode(n, "ClassBody"), this.finishNode(t, e ? "ClassDeclaration" : "ClassExpression") }, B.parseClassMethod = function (t, e, n, i) { e.value = this.parseMethod(n, i), t.body.push(this.finishNode(e, "MethodDefinition")) }, B.parseClassId = function (t, e) { t.id = this.type === b.name ? this.parseIdent() : !0 === e ? this.unexpected() : null }, B.parseClassSuper = function (t) { t.superClass = this.eat(b._extends) ? this.parseExprSubscripts() : null }, B.parseExport = function (t, e) { if (this.next(), this.eat(b.star)) return this.expectContextual("from"), t.source = this.type === b.string ? this.parseExprAtom() : this.unexpected(), this.semicolon(), this.finishNode(t, "ExportAllDeclaration"); if (this.eat(b._default)) { var n; if (this.checkExport(e, "default", this.lastTokStart), this.type === b._function || (n = this.isAsyncFunction())) { var i = this.startNode(); this.next(), n && this.next(), t.declaration = this.parseFunction(i, "nullableID", !1, n) } else if (this.type === b._class) { var r = this.startNode(); t.declaration = this.parseClass(r, "nullableID") } else t.declaration = this.parseMaybeAssign(), this.semicolon(); return this.finishNode(t, "ExportDefaultDeclaration") } if (this.shouldParseExportStatement()) t.declaration = this.parseStatement(!0), "VariableDeclaration" === t.declaration.type ? this.checkVariableExport(e, t.declaration.declarations) : this.checkExport(e, t.declaration.id.name, t.declaration.id.start), t.specifiers = [], t.source = null; else { if (t.declaration = null, t.specifiers = this.parseExportSpecifiers(e), this.eatContextual("from")) t.source = this.type === b.string ? this.parseExprAtom() : this.unexpected(); else { for (var s = 0, a = t.specifiers; s < a.length; s += 1) { var o = a[s]; this.checkUnreserved(o.local) } t.source = null } this.semicolon() } return this.finishNode(t, "ExportNamedDeclaration") }, B.checkExport = function (t, e, n) { t && (O(t, e) && this.raiseRecoverable(n, "Duplicate export '" + e + "'"), t[e] = !0) }, B.checkPatternExport = function (t, e) { var n = e.type; if ("Identifier" == n) this.checkExport(t, e.name, e.start); else if ("ObjectPattern" == n) for (var i = 0, r = e.properties; i < r.length; i += 1) { var s = r[i]; this.checkPatternExport(t, s.value) } else if ("ArrayPattern" == n) for (var a = 0, o = e.elements; a < o.length; a += 1) { var u = o[a]; u && this.checkPatternExport(t, u) } else "AssignmentPattern" == n ? this.checkPatternExport(t, e.left) : "ParenthesizedExpression" == n && this.checkPatternExport(t, e.expression) }, B.checkVariableExport = function (t, e) { if (t) for (var n = 0, i = e; n < i.length; n += 1) { var r = i[n]; this.checkPatternExport(t, r.id) } }, B.shouldParseExportStatement = function () { return "var" === this.type.keyword || "const" === this.type.keyword || "class" === this.type.keyword || "function" === this.type.keyword || this.isLet() || this.isAsyncFunction() }, B.parseExportSpecifiers = function (t) { var e = [], n = !0; for (this.expect(b.braceL); !this.eat(b.braceR);) { if (n) n = !1; else if (this.expect(b.comma), this.afterTrailingComma(b.braceR)) break; var i = this.startNode(); i.local = this.parseIdent(!0), i.exported = this.eatContextual("as") ? this.parseIdent(!0) : i.local, this.checkExport(t, i.exported.name, i.exported.start), e.push(this.finishNode(i, "ExportSpecifier")) } return e }, B.parseImport = function (t) { return this.next(), this.type === b.string ? (t.specifiers = z, t.source = this.parseExprAtom()) : (t.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), t.source = this.type === b.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(t, "ImportDeclaration") }, B.parseImportSpecifiers = function () { var t = [], e = !0; if (this.type === b.name) { var n = this.startNode(); if (n.local = this.parseIdent(), this.checkLVal(n.local, "let"), t.push(this.finishNode(n, "ImportDefaultSpecifier")), !this.eat(b.comma)) return t } if (this.type === b.star) { var i = this.startNode(); return this.next(), this.expectContextual("as"), i.local = this.parseIdent(), this.checkLVal(i.local, "let"), t.push(this.finishNode(i, "ImportNamespaceSpecifier")), t } for (this.expect(b.braceL); !this.eat(b.braceR);) { if (e) e = !1; else if (this.expect(b.comma), this.afterTrailingComma(b.braceR)) break; var r = this.startNode(); r.imported = this.parseIdent(!0), this.eatContextual("as") ? r.local = this.parseIdent() : (this.checkUnreserved(r.imported), r.local = r.imported), this.checkLVal(r.local, "let"), t.push(this.finishNode(r, "ImportSpecifier")) } return t }, B.adaptDirectivePrologue = function (t) { for (var e = 0; e < t.length && this.isDirectiveCandidate(t[e]); ++e)t[e].directive = t[e].expression.raw.slice(1, -1) }, B.isDirectiveCandidate = function (t) { return "ExpressionStatement" === t.type && "Literal" === t.expression.type && "string" == typeof t.expression.value && ('"' === this.input[t.start] || "'" === this.input[t.start]) }; var W = G.prototype; W.toAssignable = function (t, e) { if (this.options.ecmaVersion >= 6 && t) switch (t.type) { case "Identifier": this.inAsync && "await" === t.name && this.raise(t.start, "Can not use 'await' as identifier inside an async function"); break; case "ObjectPattern": case "ArrayPattern": break; case "ObjectExpression": t.type = "ObjectPattern"; for (var n = 0, i = t.properties; n < i.length; n += 1) { var r = i[n]; "init" !== r.kind && this.raise(r.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(r.value, e) } break; case "ArrayExpression": t.type = "ArrayPattern", this.toAssignableList(t.elements, e); break; case "AssignmentExpression": if ("=" !== t.operator) { this.raise(t.left.end, "Only '=' operator can be used for specifying default value."); break } t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left, e); case "AssignmentPattern": break; case "ParenthesizedExpression": this.toAssignable(t.expression, e); break; case "MemberExpression": if (!e) break; default: this.raise(t.start, "Assigning to rvalue") }return t }, W.toAssignableList = function (t, e) { var n = t.length; if (n) { var i = t[n - 1]; if (i && "RestElement" == i.type)--n; else if (i && "SpreadElement" == i.type) { i.type = "RestElement"; var r = i.argument; this.toAssignable(r, e), --n } 6 === this.options.ecmaVersion && e && i && "RestElement" === i.type && "Identifier" !== i.argument.type && this.unexpected(i.argument.start) } for (var s = 0; s < n; s++) { var a = t[s]; a && this.toAssignable(a, e) } return t }, W.parseSpread = function (t) { var e = this.startNode(); return this.next(), e.argument = this.parseMaybeAssign(!1, t), this.finishNode(e, "SpreadElement") }, W.parseRestBinding = function () { var t = this.startNode(); return this.next(), 6 === this.options.ecmaVersion && this.type !== b.name && this.unexpected(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement") }, W.parseBindingAtom = function () { if (this.options.ecmaVersion >= 6) switch (this.type) { case b.bracketL: var t = this.startNode(); return this.next(), t.elements = this.parseBindingList(b.bracketR, !0, !0), this.finishNode(t, "ArrayPattern"); case b.braceL: return this.parseObj(!0) }return this.parseIdent() }, W.parseBindingList = function (t, e, n) { for (var i = [], r = !0; !this.eat(t);)if (r ? r = !1 : this.expect(b.comma), e && this.type === b.comma) i.push(null); else { if (n && this.afterTrailingComma(t)) break; if (this.type === b.ellipsis) { var s = this.parseRestBinding(); this.parseBindingListItem(s), i.push(s), this.type === b.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.expect(t); break } var a = this.parseMaybeDefault(this.start, this.startLoc); this.parseBindingListItem(a), i.push(a) } return i }, W.parseBindingListItem = function (t) { return t }, W.parseMaybeDefault = function (t, e, n) { if (n = n || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(b.eq)) return n; var i = this.startNodeAt(t, e); return i.left = n, i.right = this.parseMaybeAssign(), this.finishNode(i, "AssignmentPattern") }, W.checkLVal = function (t, e, n) { switch (t.type) { case "Identifier": this.strict && this.reservedWordsStrictBind.test(t.name) && this.raiseRecoverable(t.start, (e ? "Binding " : "Assigning to ") + t.name + " in strict mode"), n && (O(n, t.name) && this.raiseRecoverable(t.start, "Argument name clash"), n[t.name] = !0), e && "none" !== e && (("var" === e && !this.canDeclareVarName(t.name) || "var" !== e && !this.canDeclareLexicalName(t.name)) && this.raiseRecoverable(t.start, "Identifier '" + t.name + "' has already been declared"), "var" === e ? this.declareVarName(t.name) : this.declareLexicalName(t.name)); break; case "MemberExpression": e && this.raiseRecoverable(t.start, (e ? "Binding" : "Assigning to") + " member expression"); break; case "ObjectPattern": for (var i = 0, r = t.properties; i < r.length; i += 1) { var s = r[i]; this.checkLVal(s.value, e, n) } break; case "ArrayPattern": for (var a = 0, o = t.elements; a < o.length; a += 1) { var u = o[a]; u && this.checkLVal(u, e, n) } break; case "AssignmentPattern": this.checkLVal(t.left, e, n); break; case "RestElement": this.checkLVal(t.argument, e, n); break; case "ParenthesizedExpression": this.checkLVal(t.expression, e, n); break; default: this.raise(t.start, (e ? "Binding" : "Assigning to") + " rvalue") } }; var X = G.prototype; X.checkPropClash = function (t, e) { if (!(this.options.ecmaVersion >= 6 && (t.computed || t.method || t.shorthand))) { var n, i = t.key; switch (i.type) { case "Identifier": n = i.name; break; case "Literal": n = String(i.value); break; default: return }var r = t.kind; if (this.options.ecmaVersion >= 6) "__proto__" === n && "init" === r && (e.proto && this.raiseRecoverable(i.start, "Redefinition of __proto__ property"), e.proto = !0); else { var s = e[n = "$" + n]; if (s) ("init" === r ? this.strict && s.init || s.get || s.set : s.init || s[r]) && this.raiseRecoverable(i.start, "Redefinition of property"); else s = e[n] = { init: !1, get: !1, set: !1 }; s[r] = !0 } } }, X.parseExpression = function (t, e) { var n = this.start, i = this.startLoc, r = this.parseMaybeAssign(t, e); if (this.type === b.comma) { var s = this.startNodeAt(n, i); for (s.expressions = [r]; this.eat(b.comma);)s.expressions.push(this.parseMaybeAssign(t, e)); return this.finishNode(s, "SequenceExpression") } return r }, X.parseMaybeAssign = function (t, e, n) { if (this.inGenerator && this.isContextual("yield")) return this.parseYield(); var i = !1, r = -1, s = -1; e ? (r = e.parenthesizedAssign, s = e.trailingComma, e.parenthesizedAssign = e.trailingComma = -1) : (e = new j, i = !0); var a = this.start, o = this.startLoc; this.type != b.parenL && this.type != b.name || (this.potentialArrowAt = this.start); var u = this.parseMaybeConditional(t, e); if (n && (u = n.call(this, u, a, o)), this.type.isAssign) { this.checkPatternErrors(e, !0), i || j.call(e); var h = this.startNodeAt(a, o); return h.operator = this.value, h.left = this.type === b.eq ? this.toAssignable(u) : u, e.shorthandAssign = -1, this.checkLVal(u), this.next(), h.right = this.parseMaybeAssign(t), this.finishNode(h, "AssignmentExpression") } return i && this.checkExpressionErrors(e, !0), r > -1 && (e.parenthesizedAssign = r), s > -1 && (e.trailingComma = s), u }, X.parseMaybeConditional = function (t, e) { var n = this.start, i = this.startLoc, r = this.parseExprOps(t, e); if (this.checkExpressionErrors(e)) return r; if (this.eat(b.question)) { var s = this.startNodeAt(n, i); return s.test = r, s.consequent = this.parseMaybeAssign(), this.expect(b.colon), s.alternate = this.parseMaybeAssign(t), this.finishNode(s, "ConditionalExpression") } return r }, X.parseExprOps = function (t, e) { var n = this.start, i = this.startLoc, r = this.parseMaybeUnary(e, !1); return this.checkExpressionErrors(e) ? r : r.start == n && "ArrowFunctionExpression" === r.type ? r : this.parseExprOp(r, n, i, -1, t) }, X.parseExprOp = function (t, e, n, i, r) { var s = this.type.binop; if (null != s && (!r || this.type !== b._in) && s > i) { var a = this.type === b.logicalOR || this.type === b.logicalAND, o = this.value; this.next(); var u = this.start, h = this.startLoc, l = this.parseExprOp(this.parseMaybeUnary(null, !1), u, h, s, r), p = this.buildBinary(e, n, t, l, o, a); return this.parseExprOp(p, e, n, i, r) } return t }, X.buildBinary = function (t, e, n, i, r, s) { var a = this.startNodeAt(t, e); return a.left = n, a.operator = r, a.right = i, this.finishNode(a, s ? "LogicalExpression" : "BinaryExpression") }, X.parseMaybeUnary = function (t, e) { var n, i = this.start, r = this.startLoc; if (this.inAsync && this.isContextual("await")) n = this.parseAwait(), e = !0; else if (this.type.prefix) { var s = this.startNode(), a = this.type === b.incDec; s.operator = this.value, s.prefix = !0, this.next(), s.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(t, !0), a ? this.checkLVal(s.argument) : this.strict && "delete" === s.operator && "Identifier" === s.argument.type ? this.raiseRecoverable(s.start, "Deleting local variable in strict mode") : e = !0, n = this.finishNode(s, a ? "UpdateExpression" : "UnaryExpression") } else { if (n = this.parseExprSubscripts(t), this.checkExpressionErrors(t)) return n; for (; this.type.postfix && !this.canInsertSemicolon();) { var o = this.startNodeAt(i, r); o.operator = this.value, o.prefix = !1, o.argument = n, this.checkLVal(n), this.next(), n = this.finishNode(o, "UpdateExpression") } } return !e && this.eat(b.starstar) ? this.buildBinary(i, r, n, this.parseMaybeUnary(null, !1), "**", !1) : n }, X.parseExprSubscripts = function (t) { var e = this.start, n = this.startLoc, i = this.parseExprAtom(t), r = "ArrowFunctionExpression" === i.type && ")" !== this.input.slice(this.lastTokStart, this.lastTokEnd); if (this.checkExpressionErrors(t) || r) return i; var s = this.parseSubscripts(i, e, n); return t && "MemberExpression" === s.type && (t.parenthesizedAssign >= s.start && (t.parenthesizedAssign = -1), t.parenthesizedBind >= s.start && (t.parenthesizedBind = -1)), s }, X.parseSubscripts = function (t, e, n, i) { for (var r = this.options.ecmaVersion >= 8 && "Identifier" === t.type && "async" === t.name && this.lastTokEnd == t.end && !this.canInsertSemicolon(), s = void 0; ;)if ((s = this.eat(b.bracketL)) || this.eat(b.dot)) { var a = this.startNodeAt(e, n); a.object = t, a.property = s ? this.parseExpression() : this.parseIdent(!0), a.computed = !!s, s && this.expect(b.bracketR), t = this.finishNode(a, "MemberExpression") } else if (!i && this.eat(b.parenL)) { var o = new j, u = this.yieldPos, h = this.awaitPos; this.yieldPos = 0, this.awaitPos = 0; var l = this.parseExprList(b.parenR, this.options.ecmaVersion >= 8, !1, o); if (r && !this.canInsertSemicolon() && this.eat(b.arrow)) return this.checkPatternErrors(o, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = u, this.awaitPos = h, this.parseArrowExpression(this.startNodeAt(e, n), l, !0); this.checkExpressionErrors(o, !0), this.yieldPos = u || this.yieldPos, this.awaitPos = h || this.awaitPos; var p = this.startNodeAt(e, n); p.callee = t, p.arguments = l, t = this.finishNode(p, "CallExpression") } else { if (this.type !== b.backQuote) return t; var c = this.startNodeAt(e, n); c.tag = t, c.quasi = this.parseTemplate({ isTagged: !0 }), t = this.finishNode(c, "TaggedTemplateExpression") } }, X.parseExprAtom = function (t) { var e, n = this.potentialArrowAt == this.start; switch (this.type) { case b._super: return this.inFunction || this.raise(this.start, "'super' outside of function or class"), e = this.startNode(), this.next(), this.type !== b.dot && this.type !== b.bracketL && this.type !== b.parenL && this.unexpected(), this.finishNode(e, "Super"); case b._this: return e = this.startNode(), this.next(), this.finishNode(e, "ThisExpression"); case b.name: var i = this.start, r = this.startLoc, s = this.parseIdent(this.type !== b.name); if (this.options.ecmaVersion >= 8 && "async" === s.name && !this.canInsertSemicolon() && this.eat(b._function)) return this.parseFunction(this.startNodeAt(i, r), !1, !1, !0); if (n && !this.canInsertSemicolon()) { if (this.eat(b.arrow)) return this.parseArrowExpression(this.startNodeAt(i, r), [s], !1); if (this.options.ecmaVersion >= 8 && "async" === s.name && this.type === b.name) return s = this.parseIdent(), !this.canInsertSemicolon() && this.eat(b.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAt(i, r), [s], !0) } return s; case b.regexp: var a = this.value; return (e = this.parseLiteral(a.value)).regex = { pattern: a.pattern, flags: a.flags }, e; case b.num: case b.string: return this.parseLiteral(this.value); case b._null: case b._true: case b._false: return (e = this.startNode()).value = this.type === b._null ? null : this.type === b._true, e.raw = this.type.keyword, this.next(), this.finishNode(e, "Literal"); case b.parenL: var o = this.start, u = this.parseParenAndDistinguishExpression(n); return t && (t.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(u) && (t.parenthesizedAssign = o), t.parenthesizedBind < 0 && (t.parenthesizedBind = o)), u; case b.bracketL: return e = this.startNode(), this.next(), e.elements = this.parseExprList(b.bracketR, !0, !0, t), this.finishNode(e, "ArrayExpression"); case b.braceL: return this.parseObj(!1, t); case b._function: return e = this.startNode(), this.next(), this.parseFunction(e, !1); case b._class: return this.parseClass(this.startNode(), !1); case b._new: return this.parseNew(); case b.backQuote: return this.parseTemplate(); default: this.unexpected() } }, X.parseLiteral = function (t) { var e = this.startNode(); return e.value = t, e.raw = this.input.slice(this.start, this.end), this.next(), this.finishNode(e, "Literal") }, X.parseParenExpression = function () { this.expect(b.parenL); var t = this.parseExpression(); return this.expect(b.parenR), t }, X.parseParenAndDistinguishExpression = function (t) { var e, n = this.start, i = this.startLoc, r = this.options.ecmaVersion >= 8; if (this.options.ecmaVersion >= 6) { this.next(); var s, a, o = this.start, u = this.startLoc, h = [], l = !0, p = !1, c = new j, f = this.yieldPos, d = this.awaitPos; for (this.yieldPos = 0, this.awaitPos = 0; this.type !== b.parenR;) { if (l ? l = !1 : this.expect(b.comma), r && this.afterTrailingComma(b.parenR, !0)) { p = !0; break } if (this.type === b.ellipsis) { s = this.start, h.push(this.parseParenItem(this.parseRestBinding())), this.type === b.comma && this.raise(this.start, "Comma is not permitted after the rest element"); break } this.type !== b.parenL || a || (a = this.start), h.push(this.parseMaybeAssign(!1, c, this.parseParenItem)) } var m = this.start, g = this.startLoc; if (this.expect(b.parenR), t && !this.canInsertSemicolon() && this.eat(b.arrow)) return this.checkPatternErrors(c, !1), this.checkYieldAwaitInDefaultParams(), a && this.unexpected(a), this.yieldPos = f, this.awaitPos = d, this.parseParenArrowList(n, i, h); h.length && !p || this.unexpected(this.lastTokStart), s && this.unexpected(s), this.checkExpressionErrors(c, !0), this.yieldPos = f || this.yieldPos, this.awaitPos = d || this.awaitPos, h.length > 1 ? ((e = this.startNodeAt(o, u)).expressions = h, this.finishNodeAt(e, "SequenceExpression", m, g)) : e = h[0] } else e = this.parseParenExpression(); if (this.options.preserveParens) { var y = this.startNodeAt(n, i); return y.expression = e, this.finishNode(y, "ParenthesizedExpression") } return e }, X.parseParenItem = function (t) { return t }, X.parseParenArrowList = function (t, e, n) { return this.parseArrowExpression(this.startNodeAt(t, e), n) }; var q = []; X.parseNew = function () { var t = this.startNode(), e = this.parseIdent(!0); if (this.options.ecmaVersion >= 6 && this.eat(b.dot)) return t.meta = e, t.property = this.parseIdent(!0), "target" !== t.property.name && this.raiseRecoverable(t.property.start, "The only valid meta property for new is new.target"), this.inFunction || this.raiseRecoverable(t.start, "new.target can only be used in functions"), this.finishNode(t, "MetaProperty"); var n = this.start, i = this.startLoc; return t.callee = this.parseSubscripts(this.parseExprAtom(), n, i, !0), this.eat(b.parenL) ? t.arguments = this.parseExprList(b.parenR, this.options.ecmaVersion >= 8, !1) : t.arguments = q, this.finishNode(t, "NewExpression") }, X.parseTemplateElement = function (t) { var e = t.isTagged, n = this.startNode(); return this.type === b.invalidTemplate ? (e || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), n.value = { raw: this.value, cooked: null }) : n.value = { raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"), cooked: this.value }, this.next(), n.tail = this.type === b.backQuote, this.finishNode(n, "TemplateElement") }, X.parseTemplate = function (t) { void 0 === t && (t = {}); var e = t.isTagged; void 0 === e && (e = !1); var n = this.startNode(); this.next(), n.expressions = []; var i = this.parseTemplateElement({ isTagged: e }); for (n.quasis = [i]; !i.tail;)this.expect(b.dollarBraceL), n.expressions.push(this.parseExpression()), this.expect(b.braceR), n.quasis.push(i = this.parseTemplateElement({ isTagged: e })); return this.next(), this.finishNode(n, "TemplateLiteral") }, X.isAsyncProp = function (t) { return !t.computed && "Identifier" === t.key.type && "async" === t.key.name && (this.type === b.name || this.type === b.num || this.type === b.string || this.type === b.bracketL || this.type.keyword) && !x.test(this.input.slice(this.lastTokEnd, this.start)) }, X.parseObj = function (t, e) { var n = this.startNode(), i = !0, r = {}; for (n.properties = [], this.next(); !this.eat(b.braceR);) { if (i) i = !1; else if (this.expect(b.comma), this.afterTrailingComma(b.braceR)) break; var s = this.parseProperty(t, e); this.checkPropClash(s, r), n.properties.push(s) } return this.finishNode(n, t ? "ObjectPattern" : "ObjectExpression") }, X.parseProperty = function (t, e) { var n, i, r, s, a = this.startNode(); return this.options.ecmaVersion >= 6 && (a.method = !1, a.shorthand = !1, (t || e) && (r = this.start, s = this.startLoc), t || (n = this.eat(b.star))), this.parsePropertyName(a), !t && this.options.ecmaVersion >= 8 && !n && this.isAsyncProp(a) ? (i = !0, this.parsePropertyName(a, e)) : i = !1, this.parsePropertyValue(a, t, n, i, r, s, e), this.finishNode(a, "Property") }, X.parsePropertyValue = function (t, e, n, i, r, s, a) { if ((n || i) && this.type === b.colon && this.unexpected(), this.eat(b.colon)) t.value = e ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, a), t.kind = "init"; else if (this.options.ecmaVersion >= 6 && this.type === b.parenL) e && this.unexpected(), t.kind = "init", t.method = !0, t.value = this.parseMethod(n, i); else if (e || !(this.options.ecmaVersion >= 5) || t.computed || "Identifier" !== t.key.type || "get" !== t.key.name && "set" !== t.key.name || this.type == b.comma || this.type == b.braceR) this.options.ecmaVersion >= 6 && !t.computed && "Identifier" === t.key.type ? (this.checkUnreserved(t.key), t.kind = "init", e ? t.value = this.parseMaybeDefault(r, s, t.key) : this.type === b.eq && a ? (a.shorthandAssign < 0 && (a.shorthandAssign = this.start), t.value = this.parseMaybeDefault(r, s, t.key)) : t.value = t.key, t.shorthand = !0) : this.unexpected(); else { (n || i) && this.unexpected(), t.kind = t.key.name, this.parsePropertyName(t), t.value = this.parseMethod(!1); var o = "get" === t.kind ? 0 : 1; if (t.value.params.length !== o) { var u = t.value.start; "get" === t.kind ? this.raiseRecoverable(u, "getter should have no params") : this.raiseRecoverable(u, "setter should have exactly one param") } else "set" === t.kind && "RestElement" === t.value.params[0].type && this.raiseRecoverable(t.value.params[0].start, "Setter cannot use rest params") } }, X.parsePropertyName = function (t) { if (this.options.ecmaVersion >= 6) { if (this.eat(b.bracketL)) return t.computed = !0, t.key = this.parseMaybeAssign(), this.expect(b.bracketR), t.key; t.computed = !1 } return t.key = this.type === b.num || this.type === b.string ? this.parseExprAtom() : this.parseIdent(!0) }, X.initFunction = function (t) { t.id = null, this.options.ecmaVersion >= 6 && (t.generator = !1, t.expression = !1), this.options.ecmaVersion >= 8 && (t.async = !1) }, X.parseMethod = function (t, e) { var n = this.startNode(), i = this.inGenerator, r = this.inAsync, s = this.yieldPos, a = this.awaitPos, o = this.inFunction; return this.initFunction(n), this.options.ecmaVersion >= 6 && (n.generator = t), this.options.ecmaVersion >= 8 && (n.async = !!e), this.inGenerator = n.generator, this.inAsync = n.async, this.yieldPos = 0, this.awaitPos = 0, this.inFunction = !0, this.enterFunctionScope(), this.expect(b.parenL), n.params = this.parseBindingList(b.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(n, !1), this.inGenerator = i, this.inAsync = r, this.yieldPos = s, this.awaitPos = a, this.inFunction = o, this.finishNode(n, "FunctionExpression") }, X.parseArrowExpression = function (t, e, n) { var i = this.inGenerator, r = this.inAsync, s = this.yieldPos, a = this.awaitPos, o = this.inFunction; return this.enterFunctionScope(), this.initFunction(t), this.options.ecmaVersion >= 8 && (t.async = !!n), this.inGenerator = !1, this.inAsync = t.async, this.yieldPos = 0, this.awaitPos = 0, this.inFunction = !0, t.params = this.toAssignableList(e, !0), this.parseFunctionBody(t, !0), this.inGenerator = i, this.inAsync = r, this.yieldPos = s, this.awaitPos = a, this.inFunction = o, this.finishNode(t, "ArrowFunctionExpression") }, X.parseFunctionBody = function (t, e) { var n = e && this.type !== b.braceL, i = this.strict, r = !1; if (n) t.body = this.parseMaybeAssign(), t.expression = !0, this.checkParams(t, !1); else { var s = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(t.params); i && !s || (r = this.strictDirective(this.end)) && s && this.raiseRecoverable(t.start, "Illegal 'use strict' directive in function with non-simple parameter list"); var a = this.labels; this.labels = [], r && (this.strict = !0), this.checkParams(t, !i && !r && !e && this.isSimpleParamList(t.params)), t.body = this.parseBlock(!1), t.expression = !1, this.adaptDirectivePrologue(t.body.body), this.labels = a } this.exitFunctionScope(), this.strict && t.id && this.checkLVal(t.id, "none"), this.strict = i }, X.isSimpleParamList = function (t) { for (var e = 0, n = t; e < n.length; e += 1) { if ("Identifier" !== n[e].type) return !1 } return !0 }, X.checkParams = function (t, e) { for (var n = {}, i = 0, r = t.params; i < r.length; i += 1) { var s = r[i]; this.checkLVal(s, "var", e ? null : n) } }, X.parseExprList = function (t, e, n, i) { for (var r = [], s = !0; !this.eat(t);) { if (s) s = !1; else if (this.expect(b.comma), e && this.afterTrailingComma(t)) break; var a = void 0; n && this.type === b.comma ? a = null : this.type === b.ellipsis ? (a = this.parseSpread(i), i && this.type === b.comma && i.trailingComma < 0 && (i.trailingComma = this.start)) : a = this.parseMaybeAssign(!1, i), r.push(a) } return r }, X.checkUnreserved = function (t) { var e = t.start, n = t.end, i = t.name; (this.inGenerator && "yield" === i && this.raiseRecoverable(e, "Can not use 'yield' as identifier inside a generator"), this.inAsync && "await" === i && this.raiseRecoverable(e, "Can not use 'await' as identifier inside an async function"), this.isKeyword(i) && this.raise(e, "Unexpected keyword '" + i + "'"), this.options.ecmaVersion < 6 && -1 != this.input.slice(e, n).indexOf("\\")) || (this.strict ? this.reservedWordsStrict : this.reservedWords).test(i) && this.raiseRecoverable(e, "The keyword '" + i + "' is reserved") }, X.parseIdent = function (t, e) { var n = this.startNode(); return t && "never" == this.options.allowReserved && (t = !1), this.type === b.name ? n.name = this.value : this.type.keyword ? (n.name = this.type.keyword, "class" !== n.name && "function" !== n.name || this.lastTokEnd === this.lastTokStart + 1 && 46 === this.input.charCodeAt(this.lastTokStart) || this.context.pop()) : this.unexpected(), this.next(), this.finishNode(n, "Identifier"), t || this.checkUnreserved(n), n }, X.parseYield = function () { this.yieldPos || (this.yieldPos = this.start); var t = this.startNode(); return this.next(), this.type == b.semi || this.canInsertSemicolon() || this.type != b.star && !this.type.startsExpr ? (t.delegate = !1, t.argument = null) : (t.delegate = this.eat(b.star), t.argument = this.parseMaybeAssign()), this.finishNode(t, "YieldExpression") }, X.parseAwait = function () { this.awaitPos || (this.awaitPos = this.start); var t = this.startNode(); return this.next(), t.argument = this.parseMaybeUnary(null, !0), this.finishNode(t, "AwaitExpression") }; var Y = G.prototype; Y.raise = function (t, e) { var n = F(this.input, t); e += " (" + n.line + ":" + n.column + ")"; var i = new SyntaxError(e); throw i.pos = t, i.loc = n, i.raisedAt = this.pos, i }, Y.raiseRecoverable = Y.raise, Y.curPosition = function () { if (this.options.locations) return new P(this.curLine, this.pos - this.lineStart) }; var J = G.prototype, H = Object.assign || function (t) { for (var e = [], n = arguments.length - 1; n-- > 0;)e[n] = arguments[n + 1]; for (var i = 0, r = e; i < r.length; i += 1) { var s = r[i]; for (var a in s) O(s, a) && (t[a] = s[a]) } return t }; J.enterFunctionScope = function () { this.scopeStack.push({ var: {}, lexical: {}, childVar: {}, parentLexical: {} }) }, J.exitFunctionScope = function () { this.scopeStack.pop() }, J.enterLexicalScope = function () { var t = this.scopeStack[this.scopeStack.length - 1], e = { var: {}, lexical: {}, childVar: {}, parentLexical: {} }; this.scopeStack.push(e), H(e.parentLexical, t.lexical, t.parentLexical) }, J.exitLexicalScope = function () { var t = this.scopeStack.pop(), e = this.scopeStack[this.scopeStack.length - 1]; H(e.childVar, t.var, t.childVar) }, J.canDeclareVarName = function (t) { var e = this.scopeStack[this.scopeStack.length - 1]; return !O(e.lexical, t) && !O(e.parentLexical, t) }, J.canDeclareLexicalName = function (t) { var e = this.scopeStack[this.scopeStack.length - 1]; return !O(e.lexical, t) && !O(e.var, t) && !O(e.childVar, t) }, J.declareVarName = function (t) { this.scopeStack[this.scopeStack.length - 1].var[t] = !0 }, J.declareLexicalName = function (t) { this.scopeStack[this.scopeStack.length - 1].lexical[t] = !0 }; var Z = function (t, e, n) { this.type = "", this.start = e, this.end = 0, t.options.locations && (this.loc = new C(t, n)), t.options.directSourceFile && (this.sourceFile = t.options.directSourceFile), t.options.ranges && (this.range = [e, 0]) }, $ = G.prototype; function Q(t, e, n, i) { return t.type = e, t.end = n, this.options.locations && (t.loc.end = i), this.options.ranges && (t.range[1] = n), t } $.startNode = function () { return new Z(this, this.start, this.startLoc) }, $.startNodeAt = function (t, e) { return new Z(this, t, e) }, $.finishNode = function (t, e) { return Q.call(this, t, e, this.lastTokEnd, this.lastTokEndLoc) }, $.finishNodeAt = function (t, e, n, i) { return Q.call(this, t, e, n, i) }; var tt = function (t, e, n, i, r) { this.token = t, this.isExpr = !!e, this.preserveSpace = !!n, this.override = i, this.generator = !!r }, et = { b_stat: new tt("{", !1), b_expr: new tt("{", !0), b_tmpl: new tt("${", !1), p_stat: new tt("(", !1), p_expr: new tt("(", !0), q_tmpl: new tt("`", !0, !0, function (t) { return t.tryReadTemplateToken() }), f_stat: new tt("function", !1), f_expr: new tt("function", !0), f_expr_gen: new tt("function", !0, !1, null, !0), f_gen: new tt("function", !1, !1, null, !0) }, nt = G.prototype; nt.initialContext = function () { return [et.b_stat] }, nt.braceIsBlock = function (t) { var e = this.curContext(); return e === et.f_expr || e === et.f_stat || (t !== b.colon || e !== et.b_stat && e !== et.b_expr ? t === b._return || t == b.name && this.exprAllowed ? x.test(this.input.slice(this.lastTokEnd, this.start)) : t === b._else || t === b.semi || t === b.eof || t === b.parenR || t == b.arrow || (t == b.braceL ? e === et.b_stat : t != b._var && t != b.name && !this.exprAllowed) : !e.isExpr) }, nt.inGeneratorContext = function () { for (var t = this.context.length - 1; t >= 1; t--) { var e = this.context[t]; if ("function" === e.token) return e.generator } return !1 }, nt.updateContext = function (t) { var e, n = this.type; n.keyword && t == b.dot ? this.exprAllowed = !1 : (e = n.updateContext) ? e.call(this, t) : this.exprAllowed = n.beforeExpr }, b.parenR.updateContext = b.braceR.updateContext = function () { if (1 != this.context.length) { var t = this.context.pop(); t === et.b_stat && "function" === this.curContext().token && (t = this.context.pop()), this.exprAllowed = !t.isExpr } else this.exprAllowed = !0 }, b.braceL.updateContext = function (t) { this.context.push(this.braceIsBlock(t) ? et.b_stat : et.b_expr), this.exprAllowed = !0 }, b.dollarBraceL.updateContext = function () { this.context.push(et.b_tmpl), this.exprAllowed = !0 }, b.parenL.updateContext = function (t) { var e = t === b._if || t === b._for || t === b._with || t === b._while; this.context.push(e ? et.p_stat : et.p_expr), this.exprAllowed = !0 }, b.incDec.updateContext = function () { }, b._function.updateContext = b._class.updateContext = function (t) { t.beforeExpr && t !== b.semi && t !== b._else && (t !== b.colon && t !== b.braceL || this.curContext() !== et.b_stat) ? this.context.push(et.f_expr) : this.context.push(et.f_stat), this.exprAllowed = !1 }, b.backQuote.updateContext = function () { this.curContext() === et.q_tmpl ? this.context.pop() : this.context.push(et.q_tmpl), this.exprAllowed = !1 }, b.star.updateContext = function (t) { if (t == b._function) { var e = this.context.length - 1; this.context[e] === et.f_expr ? this.context[e] = et.f_expr_gen : this.context[e] = et.f_gen } this.exprAllowed = !0 }, b.name.updateContext = function (t) { var e = !1; this.options.ecmaVersion >= 6 && ("of" == this.value && !this.exprAllowed || "yield" == this.value && this.inGeneratorContext()) && (e = !0), this.exprAllowed = e }; var it = function (t) { this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, t.options.locations && (this.loc = new C(t, t.startLoc, t.endLoc)), t.options.ranges && (this.range = [t.start, t.end]) }, rt = G.prototype, st = "object" == typeof Packages && "[object JavaPackage]" == Object.prototype.toString.call(Packages); function at(t, e, n, i) { try { return new RegExp(t, e) } catch (t) { if (void 0 !== n) throw t instanceof SyntaxError && i.raise(n, "Error parsing regular expression: " + t.message), t } } rt.next = function () { this.options.onToken && this.options.onToken(new it(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken() }, rt.getToken = function () { return this.next(), new it(this) }, "undefined" != typeof Symbol && (rt[Symbol.iterator] = function () { var t = this; return { next: function () { var e = t.getToken(); return { done: e.type === b.eof, value: e } } } }), rt.curContext = function () { return this.context[this.context.length - 1] }, rt.nextToken = function () { var t = this.curContext(); return t && t.preserveSpace || this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length ? this.finishToken(b.eof) : t.override ? t.override(this) : void this.readToken(this.fullCharCodeAtPos()) }, rt.readToken = function (t) { return p(t, this.options.ecmaVersion >= 6) || 92 === t ? this.readWord() : this.getTokenFromCode(t) }, rt.fullCharCodeAtPos = function () { var t = this.input.charCodeAt(this.pos); return t <= 55295 || t >= 57344 ? t : (t << 10) + this.input.charCodeAt(this.pos + 1) - 56613888 }, rt.skipBlockComment = function () { var t, e = this.options.onComment && this.curPosition(), n = this.pos, i = this.input.indexOf("*/", this.pos += 2); if (-1 === i && this.raise(this.pos - 2, "Unterminated comment"), this.pos = i + 2, this.options.locations) for (k.lastIndex = n; (t = k.exec(this.input)) && t.index < this.pos;)++this.curLine, this.lineStart = t.index + t[0].length; this.options.onComment && this.options.onComment(!0, this.input.slice(n + 2, i), n, this.pos, e, this.curPosition()) }, rt.skipLineComment = function (t) { for (var e = this.pos, n = this.options.onComment && this.curPosition(), i = this.input.charCodeAt(this.pos += t); this.pos < this.input.length && !E(i);)i = this.input.charCodeAt(++this.pos); this.options.onComment && this.options.onComment(!1, this.input.slice(e + t, this.pos), e, this.pos, n, this.curPosition()) }, rt.skipSpace = function () { t: for (; this.pos < this.input.length;) { var t = this.input.charCodeAt(this.pos); switch (t) { case 32: case 160: ++this.pos; break; case 13: 10 === this.input.charCodeAt(this.pos + 1) && ++this.pos; case 10: case 8232: case 8233: ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos); break; case 47: switch (this.input.charCodeAt(this.pos + 1)) { case 42: this.skipBlockComment(); break; case 47: this.skipLineComment(2); break; default: break t }break; default: if (!(t > 8 && t < 14 || t >= 5760 && S.test(String.fromCharCode(t)))) break t; ++this.pos } } }, rt.finishToken = function (t, e) { this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition()); var n = this.type; this.type = t, this.value = e, this.updateContext(n) }, rt.readToken_dot = function () { var t = this.input.charCodeAt(this.pos + 1); if (t >= 48 && t <= 57) return this.readNumber(!0); var e = this.input.charCodeAt(this.pos + 2); return this.options.ecmaVersion >= 6 && 46 === t && 46 === e ? (this.pos += 3, this.finishToken(b.ellipsis)) : (++this.pos, this.finishToken(b.dot)) }, rt.readToken_slash = function () { var t = this.input.charCodeAt(this.pos + 1); return this.exprAllowed ? (++this.pos, this.readRegexp()) : 61 === t ? this.finishOp(b.assign, 2) : this.finishOp(b.slash, 1) }, rt.readToken_mult_modulo_exp = function (t) { var e = this.input.charCodeAt(this.pos + 1), n = 1, i = 42 === t ? b.star : b.modulo; return this.options.ecmaVersion >= 7 && 42 == t && 42 === e && (++n, i = b.starstar, e = this.input.charCodeAt(this.pos + 2)), 61 === e ? this.finishOp(b.assign, n + 1) : this.finishOp(i, n) }, rt.readToken_pipe_amp = function (t) { var e = this.input.charCodeAt(this.pos + 1); return e === t ? this.finishOp(124 === t ? b.logicalOR : b.logicalAND, 2) : 61 === e ? this.finishOp(b.assign, 2) : this.finishOp(124 === t ? b.bitwiseOR : b.bitwiseAND, 1) }, rt.readToken_caret = function () { return 61 === this.input.charCodeAt(this.pos + 1) ? this.finishOp(b.assign, 2) : this.finishOp(b.bitwiseXOR, 1) }, rt.readToken_plus_min = function (t) { var e = this.input.charCodeAt(this.pos + 1); return e === t ? 45 != e || this.inModule || 62 != this.input.charCodeAt(this.pos + 2) || 0 !== this.lastTokEnd && !x.test(this.input.slice(this.lastTokEnd, this.pos)) ? this.finishOp(b.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : 61 === e ? this.finishOp(b.assign, 2) : this.finishOp(b.plusMin, 1) }, rt.readToken_lt_gt = function (t) { var e = this.input.charCodeAt(this.pos + 1), n = 1; return e === t ? (n = 62 === t && 62 === this.input.charCodeAt(this.pos + 2) ? 3 : 2, 61 === this.input.charCodeAt(this.pos + n) ? this.finishOp(b.assign, n + 1) : this.finishOp(b.bitShift, n)) : 33 != e || 60 != t || this.inModule || 45 != this.input.charCodeAt(this.pos + 2) || 45 != this.input.charCodeAt(this.pos + 3) ? (61 === e && (n = 2), this.finishOp(b.relational, n)) : (this.skipLineComment(4), this.skipSpace(), this.nextToken()) }, rt.readToken_eq_excl = function (t) { var e = this.input.charCodeAt(this.pos + 1); return 61 === e ? this.finishOp(b.equality, 61 === this.input.charCodeAt(this.pos + 2) ? 3 : 2) : 61 === t && 62 === e && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(b.arrow)) : this.finishOp(61 === t ? b.eq : b.prefix, 1) }, rt.getTokenFromCode = function (t) { switch (t) { case 46: return this.readToken_dot(); case 40: return ++this.pos, this.finishToken(b.parenL); case 41: return ++this.pos, this.finishToken(b.parenR); case 59: return ++this.pos, this.finishToken(b.semi); case 44: return ++this.pos, this.finishToken(b.comma); case 91: return ++this.pos, this.finishToken(b.bracketL); case 93: return ++this.pos, this.finishToken(b.bracketR); case 123: return ++this.pos, this.finishToken(b.braceL); case 125: return ++this.pos, this.finishToken(b.braceR); case 58: return ++this.pos, this.finishToken(b.colon); case 63: return ++this.pos, this.finishToken(b.question); case 96: if (this.options.ecmaVersion < 6) break; return ++this.pos, this.finishToken(b.backQuote); case 48: var e = this.input.charCodeAt(this.pos + 1); if (120 === e || 88 === e) return this.readRadixNumber(16); if (this.options.ecmaVersion >= 6) { if (111 === e || 79 === e) return this.readRadixNumber(8); if (98 === e || 66 === e) return this.readRadixNumber(2) } case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: return this.readNumber(!1); case 34: case 39: return this.readString(t); case 47: return this.readToken_slash(); case 37: case 42: return this.readToken_mult_modulo_exp(t); case 124: case 38: return this.readToken_pipe_amp(t); case 94: return this.readToken_caret(); case 43: case 45: return this.readToken_plus_min(t); case 60: case 62: return this.readToken_lt_gt(t); case 61: case 33: return this.readToken_eq_excl(t); case 126: return this.finishOp(b.prefix, 1) }this.raise(this.pos, "Unexpected character '" + ut(t) + "'") }, rt.finishOp = function (t, e) { var n = this.input.slice(this.pos, this.pos + e); return this.pos += e, this.finishToken(t, n) }; var ot = !!at("￿", "u"); function ut(t) { return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode(55296 + (t >> 10), 56320 + (1023 & t))) } rt.readRegexp = function () { for (var t, e, n = this, i = this.pos; ;) { n.pos >= n.input.length && n.raise(i, "Unterminated regular expression"); var r = n.input.charAt(n.pos); if (x.test(r) && n.raise(i, "Unterminated regular expression"), t) t = !1; else { if ("[" === r) e = !0; else if ("]" === r && e) e = !1; else if ("/" === r && !e) break; t = "\\" === r } ++n.pos } var s = this.input.slice(i, this.pos); ++this.pos; var a = this.readWord1(), o = s, u = ""; if (a) { var h = /^[gim]*$/; this.options.ecmaVersion >= 6 && (h = /^[gimuy]*$/), h.test(a) || this.raise(i, "Invalid regular expression flag"), a.indexOf("u") >= 0 && (ot ? u = "u" : (o = (o = o.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (t, e, r) { return (e = Number("0x" + e)) > 1114111 && n.raise(i + r + 3, "Code point out of bounds"), "x" })).replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x"), u = u.replace("u", ""))) } var l = null; return st || (at(o, u, i, this), l = at(s, a)), this.finishToken(b.regexp, { pattern: s, flags: a, value: l }) }, rt.readInt = function (t, e) { for (var n = this.pos, i = 0, r = 0, s = null == e ? 1 / 0 : e; r < s; ++r) { var a = this.input.charCodeAt(this.pos), o = void 0; if ((o = a >= 97 ? a - 97 + 10 : a >= 65 ? a - 65 + 10 : a >= 48 && a <= 57 ? a - 48 : 1 / 0) >= t) break; ++this.pos, i = i * t + o } return this.pos === n || null != e && this.pos - n !== e ? null : i }, rt.readRadixNumber = function (t) { this.pos += 2; var e = this.readInt(t); return null == e && this.raise(this.start + 2, "Expected number in radix " + t), p(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(b.num, e) }, rt.readNumber = function (t) { var e = this.pos, n = !1, i = 48 === this.input.charCodeAt(this.pos); t || null !== this.readInt(10) || this.raise(e, "Invalid number"), i && this.pos == e + 1 && (i = !1); var r = this.input.charCodeAt(this.pos); 46 !== r || i || (++this.pos, this.readInt(10), n = !0, r = this.input.charCodeAt(this.pos)), 69 !== r && 101 !== r || i || (43 !== (r = this.input.charCodeAt(++this.pos)) && 45 !== r || ++this.pos, null === this.readInt(10) && this.raise(e, "Invalid number"), n = !0), p(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"); var s, a = this.input.slice(e, this.pos); return n ? s = parseFloat(a) : i && 1 !== a.length ? this.strict ? this.raise(e, "Invalid number") : s = /[89]/.test(a) ? parseInt(a, 10) : parseInt(a, 8) : s = parseInt(a, 10), this.finishToken(b.num, s) }, rt.readCodePoint = function () { var t; if (123 === this.input.charCodeAt(this.pos)) { this.options.ecmaVersion < 6 && this.unexpected(); var e = ++this.pos; t = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, t > 1114111 && this.invalidStringToken(e, "Code point out of bounds") } else t = this.readHexChar(4); return t }, rt.readString = function (t) { for (var e = "", n = ++this.pos; ;) { this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant"); var i = this.input.charCodeAt(this.pos); if (i === t) break; 92 === i ? (e += this.input.slice(n, this.pos), e += this.readEscapedChar(!1), n = this.pos) : (E(i) && this.raise(this.start, "Unterminated string constant"), ++this.pos) } return e += this.input.slice(n, this.pos++), this.finishToken(b.string, e) }; var ht = {}; rt.tryReadTemplateToken = function () { this.inTemplateElement = !0; try { this.readTmplToken() } catch (t) { if (t !== ht) throw t; this.readInvalidTemplateToken() } this.inTemplateElement = !1 }, rt.invalidStringToken = function (t, e) { if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw ht; this.raise(t, e) }, rt.readTmplToken = function () { for (var t = "", e = this.pos; ;) { this.pos >= this.input.length && this.raise(this.start, "Unterminated template"); var n = this.input.charCodeAt(this.pos); if (96 === n || 36 === n && 123 === this.input.charCodeAt(this.pos + 1)) return this.pos !== this.start || this.type !== b.template && this.type !== b.invalidTemplate ? (t += this.input.slice(e, this.pos), this.finishToken(b.template, t)) : 36 === n ? (this.pos += 2, this.finishToken(b.dollarBraceL)) : (++this.pos, this.finishToken(b.backQuote)); if (92 === n) t += this.input.slice(e, this.pos), t += this.readEscapedChar(!0), e = this.pos; else if (E(n)) { switch (t += this.input.slice(e, this.pos), ++this.pos, n) { case 13: 10 === this.input.charCodeAt(this.pos) && ++this.pos; case 10: t += "\n"; break; default: t += String.fromCharCode(n) }this.options.locations && (++this.curLine, this.lineStart = this.pos), e = this.pos } else ++this.pos } }, rt.readInvalidTemplateToken = function () { for (; this.pos < this.input.length; this.pos++)switch (this.input[this.pos]) { case "\\": ++this.pos; break; case "$": if ("{" !== this.input[this.pos + 1]) break; case "`": return this.finishToken(b.invalidTemplate, this.input.slice(this.start, this.pos)) }this.raise(this.start, "Unterminated template") }, rt.readEscapedChar = function (t) { var e = this.input.charCodeAt(++this.pos); switch (++this.pos, e) { case 110: return "\n"; case 114: return "\r"; case 120: return String.fromCharCode(this.readHexChar(2)); case 117: return ut(this.readCodePoint()); case 116: return "\t"; case 98: return "\b"; case 118: return "\v"; case 102: return "\f"; case 13: 10 === this.input.charCodeAt(this.pos) && ++this.pos; case 10: return this.options.locations && (this.lineStart = this.pos, ++this.curLine), ""; default: if (e >= 48 && e <= 55) { var n = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], i = parseInt(n, 8); return i > 255 && (n = n.slice(0, -1), i = parseInt(n, 8)), "0" !== n && (this.strict || t) && this.invalidStringToken(this.pos - 2, "Octal literal in strict mode"), this.pos += n.length - 1, String.fromCharCode(i) } return String.fromCharCode(e) } }, rt.readHexChar = function (t) { var e = this.pos, n = this.readInt(16, t); return null === n && this.invalidStringToken(e, "Bad character escape sequence"), n }, rt.readWord1 = function () { this.containsEsc = !1; for (var t = "", e = !0, n = this.pos, i = this.options.ecmaVersion >= 6; this.pos < this.input.length;) { var r = this.fullCharCodeAtPos(); if (c(r, i)) this.pos += r <= 65535 ? 1 : 2; else { if (92 !== r) break; this.containsEsc = !0, t += this.input.slice(n, this.pos); var s = this.pos; 117 != this.input.charCodeAt(++this.pos) && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos; var a = this.readCodePoint(); (e ? p : c)(a, i) || this.invalidStringToken(s, "Invalid Unicode escape"), t += ut(a), n = this.pos } e = !1 } return t + this.input.slice(n, this.pos) }, rt.readWord = function () { var t = this.readWord1(), e = b.name; return this.keywords.test(t) && (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + t), e = y[t]), this.finishToken(e, t) }, t.version = "5.2.1", t.parse = function (t, e) { return new G(e, t).parse() }, t.parseExpressionAt = function (t, e, n) { var i = new G(n, t, e); return i.nextToken(), i.parseExpression() }, t.tokenizer = function (t, e) { return new G(e, t) }, t.addLooseExports = function (e, n, i) { t.parse_dammit = e, t.LooseParser = n, t.pluginsLoose = i }, t.Parser = G, t.plugins = I, t.defaultOptions = R, t.Position = P, t.SourceLocation = C, t.getLineInfo = F, t.Node = Z, t.TokenType = f, t.tokTypes = b, t.keywordTypes = y, t.TokContext = tt, t.tokContexts = et, t.isIdentifierChar = c, t.isIdentifierStart = p, t.Token = it, t.isNewLine = E, t.lineBreak = x, t.lineBreakG = k, t.nonASCIIwhitespace = S, Object.defineProperty(t, "__esModule", { value: !0 }) }, "object" == typeof n && void 0 !== e ? r(n) : "function" == typeof define && define.amd ? define(["exports"], r) : r(i.acorn = i.acorn || {}) }, {}] }, {}, [26]); const gpu = new GPU, multiplyMatrix = gpu.createKernel(function (t, e) { for (var n = 0, i = 0; i < 512; i++)n += t[this.thread.y][i] * e[i][this.thread.x]; return n }).setOutput([512, 512]); function createMatrix() { for (var t = [], e = 0; e < 512; e++) { t[e] = []; for (var n = 0; n < 512; n++)t[e][n] = Math.random() } return t } var a = createMatrix(), b = createMatrix(), startTime = new Date; const c = multiplyMatrix(a, b); var endTime = new Date, timeElapesed = endTime - startTime, result, canvas = document.createElement("canvas"); try { var gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl") } catch (t) { } if (gl) var rd = gl.getParameter(gl.getExtension("WEBGL_debug_renderer_info").UNMASKED_RENDERER_WEBGL); if ("ontouchstart" in document.documentElement) var ts = 1; else var ts = 0;